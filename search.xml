<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「Go_07」流程控制</title>
    <url>/2020/03/10/go-07/</url>
    <content><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>
<p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于<strong>扩展类</strong>的流程控制。</p>
<h1 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else | 分支结构"></a>if else | 分支结构</h1><h2 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h2><p>Go语言中<code>if</code>条件判断的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 </li>
<li><code>if</code>判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</li>
<li>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if</code>和表达式放在同一行，<code>{</code>放在其他位置会触发编译错误。</li>
<li>同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	score := <span class="number">65</span></span><br><span class="line">	<span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h2><p><code>if</code>条件判断还有一种特殊的写法，可以在<code>if</code>表达式之前添加一个执行语句，再根据变量值进行判断。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for | 循环结构"></a>for | 循环结构</h1><p>Go 语言中的<strong>所有循环类型</strong>均可以使用<code>for</code>关键字来完成。</p>
<h2 id="for循环基本写法"><a href="#for循环基本写法" class="headerlink" title="for循环基本写法"></a>for循环基本写法</h2><p><code>for</code>循环的基本格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for循环省略初始语句"><a href="#for循环省略初始语句" class="headerlink" title="for循环省略初始语句"></a>for循环省略初始语句</h2><p><code>for</code>循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for循环省略初始语句和结束语句"><a href="#for循环省略初始语句和结束语句" class="headerlink" title="for循环省略初始语句和结束语句"></a>for循环省略初始语句和结束语句</h2><p><code>for</code>循环的初始语句和结束语句都可以省略，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p>
<h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range | 键值循环"></a>for range | 键值循环</h2><p>Go语言中可以使用<code>for range</code>遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<strong>map</strong>及<strong>通道</strong>（channel）。 </p>
<p>通过<code>for range</code>遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<h1 id="switch-case-简化判断"><a href="#switch-case-简化判断" class="headerlink" title="switch case | 简化判断"></a>switch case | 简化判断</h1><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	finger := <span class="number">3</span></span><br><span class="line">	<span class="keyword">switch</span> finger &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		fmt.Println(<span class="string">"大拇指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">"食指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		fmt.Println(<span class="string">"中指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		fmt.Println(<span class="string">"无名指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		fmt.Println(<span class="string">"小拇指"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"无效的输入！"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p>
<p>一个分支可以有多个值，多个<code>case</code>值中间使用英文逗号分隔。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSwitch3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">		fmt.Println(<span class="string">"奇数"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">		fmt.Println(<span class="string">"偶数"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分支还可以使用表达式，这时候<code>switch</code>语句后面不需要再跟判断变量。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	age := <span class="number">30</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">		fmt.Println(<span class="string">"好好学习吧"</span>)</span><br><span class="line">	<span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">		fmt.Println(<span class="string">"好好工作吧"</span>)</span><br><span class="line">	<span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">		fmt.Println(<span class="string">"好好享受吧"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"活着真好"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fallthrough</code>语法可以执行满足条件的<code>case</code>的下一个<code>case</code>，是为了兼容C语言中的<code>case</code>设计的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"a"</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> s == <span class="string">"a"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> s == <span class="string">"b"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">	<span class="keyword">case</span> s == <span class="string">"c"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"c"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h1 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto | 跳转到指定标签"></a>goto | 跳转到指定标签</h1><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的<code>for</code>循环要退出时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> breakFlag <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="comment">// 设置退出标签</span></span><br><span class="line">				breakFlag = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 外层for循环判断</span></span><br><span class="line">		<span class="keyword">if</span> breakFlag &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>goto</code>语句能简化代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="comment">// 设置退出标签</span></span><br><span class="line">				<span class="keyword">goto</span> breakTag</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">	<span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">	fmt.Println(<span class="string">"结束for循环"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break | 跳出循环"></a>break | 跳出循环</h1><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p>
<p><code>break</code>语句还可以在语句后面<strong>添加标签</strong>，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> BREAKDEMO1</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue | 继续下次循环"></a>continue | 继续下次循环</h1><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p>
<p>在 <code>continue</code>语句后<strong>添加标签</strong>时，表示开始标签对应的循环。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// forloop2:</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span> forloop1</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_06」运算符</title>
    <url>/2020/03/10/go-06/</url>
    <content><![CDATA[<p>Go 语言内置的运算符有：</p>
<ol>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>
<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">相加</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">相减</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">相乘</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">相除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">求余</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody></table>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody></table>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody></table>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td align="center">+=</td>
<td align="center">相加后再赋值</td>
</tr>
<tr>
<td align="center">-=</td>
<td align="center">相减后再赋值</td>
</tr>
<tr>
<td align="center">*=</td>
<td align="center">相乘后再赋值</td>
</tr>
<tr>
<td align="center">/=</td>
<td align="center">相除后再赋值</td>
</tr>
<tr>
<td align="center">%=</td>
<td align="center">求余后再赋值</td>
</tr>
<tr>
<td align="center">&lt;&lt;=</td>
<td align="center">左移后赋值</td>
</tr>
<tr>
<td align="center">&gt;&gt;=</td>
<td align="center">右移后赋值</td>
</tr>
<tr>
<td align="center">&amp;=</td>
<td align="center">按位与后赋值</td>
</tr>
<tr>
<td align="center">|=</td>
<td align="center">按位或后赋值</td>
</tr>
<tr>
<td align="center">^=</td>
<td align="center">按位异或后赋值</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_05」基本数据类型</title>
    <url>/2020/03/10/go-05/</url>
    <content><![CDATA[<h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><h2 id="普通整形"><a href="#普通整形" class="headerlink" title="普通整形"></a>普通整形</h2><p>整型分为以下两个大类： </p>
<ol>
<li>有符号整形按长度分为：<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 。</li>
<li>对应的无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>。</li>
</ol>
<blockquote>
<ul>
<li><code>uint8</code>就是我们熟知的<code>byte</code>型。</li>
<li><code>int16</code>对应C语言中的<code>short</code>型。</li>
<li><code>int64</code>对应C语言中的<code>long</code>型。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint8</td>
<td align="center">无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">有符号 8位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="center">有符号 16位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h2 id="特殊整形"><a href="#特殊整形" class="headerlink" title="特殊整形"></a>特殊整形</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong> </p>
<ol>
<li>在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在<strong>不同平台上的差异</strong>。</li>
<li>获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。</li>
<li>实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。</li>
<li>在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</li>
</ol>
</blockquote>
<h2 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h2><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以<strong>二进制</strong>、<strong>八进制</strong>或<strong>十六进制</strong>浮点数的格式定义数字，例如：</p>
<ul>
<li>v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。</li>
<li>v := 0o377，代表八进制的 377，相当于十进制的 255。</li>
<li>v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 </li>
<li>而且还允许我们用 _ 来分隔数字，比如说：v := 123_456 等于 123456。</li>
</ul>
<p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 十进制</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 八进制  以0开头</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">	fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 十六进制  以0x开头</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看变量类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T \n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准：</p>
<ol>
<li><code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</li>
<li><code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li><code>float32</code>类型的值不能直接赋值给<code>float64</code>类型的值。</li>
<li>浮点型数默认类型是<code>float64</code>，以保证更加精确。</li>
</ul>
</blockquote>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>有<code>complex64</code>和<code>complex128</code>两种类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure>

<p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位。</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true</code>（真）和<code>false</code>（假）两个值。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        b1 := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> b2 <span class="keyword">bool</span> <span class="comment">// 默认值是false</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T\n"</span>, b1)</span><br><span class="line">        <span class="comment">// %v可以将任何类型的值输出</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T value:%v\n"</span>, b2, b2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型<code>int</code>、<code>bool</code>、<code>float32</code>、<code>float64</code>等一样。 </p>
<p>Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码，<strong>支持中文</strong>。 </p>
<p>字符串的值<strong>只能</strong>用双引号<code>&quot; &quot;</code>引起，可以在Go语言的源码中直接添加<strong>非ASCII码</strong>字符，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">"hello"</span></span><br><span class="line">s2 := <span class="string">"你好"</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h2><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center"><code>\&#39;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody></table>
<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"str := \"c:\\Code\\lesson1\\go.exe\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>Go语言中要定义一个多行字符串时，就必须使用反引号<code>`</code>字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>

<p>反引号间换行将被作为字符串中的换行，但是所有的<strong>转义字符均无效</strong>，文本将会原样输出。</p>
<h2 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>
<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>
<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>
<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>
<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>
<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置</td>
</tr>
<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody></table>
<h1 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h1><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 </p>
<p>字符可以是单独的字母、<strong>汉字</strong>或符号，不一定是一个字节。</p>
<p>字符用单引号<code>&#39; &#39;</code>包裹起来，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">'中'</span></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">'x'</span></span><br></pre></td></tr></table></figure>

<p>Go 语言的字符有以下两种：</p>
<ol>
<li><code>byte</code> 类型，实际上是<code>uint8</code>类型，代表了一个ASCII码字符。</li>
<li><code>rune</code>类型，实际上是<code>int32</code>类型，代表一个 UTF-8字符。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。</p>
<ul>
<li>Go 使用了特殊的<code>rune</code>类型来处理 Unicode，让基于 Unicode 的文本处理更为方便。</li>
<li>也可以使用<code>byte</code> 型进行默认字符串处理，性能和扩展性都有照顾。</li>
</ul>
<h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"hello沙河"</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, s[i], s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, r, r)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河)</span><br></pre></td></tr></table></figure>

<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<blockquote>
<ul>
<li>字符串底层是一个<code>byte</code>数组，所以可以和<code>[]byte</code>类型相互转换。</li>
<li>字符串是不能修改的，字符串是由<code>byte</code>字节组成，所以<strong>字符串的长度是<code>byte</code>字节的长度</strong>。</li>
<li><code>rune</code>类型用来表示UTF8字符，一个<code>rune</code>字符由一个或多个<code>byte</code>组成。</li>
</ul>
</blockquote>
<h2 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h2><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">"big"</span></span><br><span class="line">	<span class="comment">// 强制类型转换</span></span><br><span class="line">	byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">	byteS1[<span class="number">0</span>] = <span class="string">'p'</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">	s2 := <span class="string">"白萝卜"</span></span><br><span class="line">	runeS2 := []<span class="keyword">rune</span>(s2)</span><br><span class="line">	runeS2[<span class="number">0</span>] = <span class="string">'红'</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Go语言中<strong>只有强制类型转换</strong>，没有隐式类型转换。该语法只能在两个类型之间<strong>支持</strong>相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure>

<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">	c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_04」变量与常量</title>
    <url>/2020/03/09/go-04/</url>
    <content><![CDATA[<h1 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。</p>
<p>Go语言中标识符由<strong>字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头</strong>。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p>
<blockquote>
<p>Go语言中推荐使用驼峰式命名。</p>
</blockquote>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p>
<p>Go语言中有25个关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure>

<p>此外，Go语言中还有37个保留字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span>  </span><br><span class="line">              <span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line">              <span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line">              <span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

<h1 id="Print函数"><a href="#Print函数" class="headerlink" title="Print函数"></a>Print函数</h1><h2 id="Print"><a href="#Print" class="headerlink" title="Print()"></a>Print()</h2><p>在终端中输出要打印的内容。</p>
<h2 id="Printf"><a href="#Printf" class="headerlink" title="Printf()"></a>Printf()</h2><p>在终端中<strong>格式化输出</strong>内容，例如可以使用<code>%s</code>占位符。</p>
<h2 id="Println"><a href="#Println" class="headerlink" title="Println()"></a>Println()</h2><p>打印完内容后在后面添加一个<strong>换行符</strong>。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul>
<li>Go语言中的变量<strong>需要声明后才能使用</strong>，同一作用域内不支持重复声明。 </li>
<li>Go语言的变量<strong>非全局</strong>声明后<strong>必须使用</strong>，全局声明后可以不用。</li>
</ul>
<h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure>

<p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>

<h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">string</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">bool</span></span><br><span class="line">    d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值。</p>
<p>例如：</p>
<ul>
<li>整型和浮点型变量的默认值为<code>0</code>。 </li>
<li>字符串变量的默认值为<code>空字符串</code>。</li>
<li>布尔型变量默认为<code>false</code>。</li>
<li>切片、函数、指针变量的默认为<code>nil</code>。</li>
</ul>
<p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Q1mi"</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>或者一次初始化多个变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">"Q1mi"</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Q1mi"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h3><p><strong>在函数内部</strong>，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">10</span></span><br><span class="line">	m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">	fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>, <span class="string">"Q1mi"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, _ := foo()</span><br><span class="line">	_, y := foo()</span><br><span class="line">	fmt.Println(<span class="string">"x="</span>, x)</span><br><span class="line">	fmt.Println(<span class="string">"y="</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<p>在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>函数外的每个语句都必须以关键字开始，例如<code>var</code>、<code>const</code>、<code>func</code>等。</li>
<li><code>:=</code>不能使用在函数外。</li>
<li><code>_</code>多用于占位，表示忽略值。</li>
</ol>
</blockquote>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h2><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p>
<h3 id="标准声明-1"><a href="#标准声明-1" class="headerlink" title="标准声明"></a>标准声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure>

<p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>
<h3 id="批量声明-1"><a href="#批量声明-1" class="headerlink" title="批量声明"></a>批量声明</h3><p>多个常量也可以一起声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>const</code>同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p>
<h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的<strong>常量</strong>计数器，只能在常量的表达式中使用。</p>
<p><code>iota</code>在<code>const</code><strong>关键字出现时</strong>将被重置为0。<code>const</code>中<strong>每新增一行</strong>常量声明将使<code>iota</code>计数一次（iota可理解为<code>const</code>语句块中的行索引）。 使用iota能简化定义，在定义枚举时很有用。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		n3        <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<hr>
<p>几个常见<code>iota</code>使用示例：</p>
<ol>
<li>使用<code>_</code>跳过某些值：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		_</span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>iota</code>声明中间插队：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">		n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义数量级 </li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		_  = <span class="literal">iota</span></span><br><span class="line">		KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的<strong>二进制</strong>表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是<strong>十进制</strong>的1024。</li>
<li>同理<code>2&lt;&lt;2</code>表示将2的<strong>二进制</strong>表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是<strong>十进制</strong>的8。</li>
</ul>
<ol start="4">
<li>多个<code>iota</code>定义在一行</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">		c, d                      <span class="comment">//2,3</span></span><br><span class="line">		e, f                      <span class="comment">//3,4</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_03」第一个Go程序</title>
    <url>/2020/03/09/go-03/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>现在我们来创建第一个Go项目——<code>hello</code>。在我们的<code>GOPATH</code>下的<code>src</code>目录中创建<code>hello</code>目录。</p>
<p>在该目录中创建一个<code>main.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 声明 main 包，表明当前是一个可执行程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  <span class="comment">// 导入内置 fmt 包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  <span class="comment">// main函数，是程序执行的入口</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello World!"</span>)  <span class="comment">// 在终端打印 Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h1><p><code>go build</code>表示将源代码编译成可执行文件。</p>
<p>在<code>hello</code>目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br></pre></td></tr></table></figure>

<p>或者在其他目录执行以下命令，需要加上项目从<code>GOPATH/src</code>后面开始的路径，编译出的可执行文件就在当前目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build hello</span><br></pre></td></tr></table></figure>

<p>go编译器会去 <code>GOPATH</code>的<code>src</code>目录下查找你要编译的<code>hello</code>项目。</p>
<p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到<code>hello.exe</code>可执行文件。</p>
<p>可在终端直接执行该<code>hello.exe</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\src\hello&gt; hello.exe</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>我们还可以使用<code>-o</code>参数来<strong>指定</strong>编译后得到的<strong>可执行文件的名字</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -o heiheihei.exe</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows下VSCode默认是<code>powershell</code>，建议切换<code>cmd</code>作为默认终端。</p>
</blockquote>
<h1 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h1><p>像执行脚本文件一样执行Go代码。</p>
<h1 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h1><p><code>go install</code>分为两步：</p>
<ol>
<li>先编译得到一个可执行文件；</li>
<li>将可执行文件拷贝到<code>GOPATH/bin</code>。</li>
</ol>
<h1 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h1><p>默认我们<code>go build</code>的可执行文件都是当前操作系统可执行的文件，如果我想在windows下编译一个linux下可执行文件，那需要怎么做呢？</p>
<p>只需要指定目标操作系统的平台和处理器架构即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用了cgo的代码是不支持跨平台编译的</p>
</blockquote>
<p>然后再执行<code>go build</code>命令，得到的就是能够在Linux平台运行的可执行文件了。</p>
<p>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

<p>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

<p>Windows下编译Mac平台64位可执行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_02」配置VSCode</title>
    <url>/2020/03/09/go-02/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>VS Code</code>全称<code>Visual Studio Code</code>，是微软公司开源的一款<strong>免费</strong>现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。</p>
<p>虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。</p>
<h1 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h1><p><code>VS Code</code><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">官方下载地址</a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="安装中文简体插件"><a href="#安装中文简体插件" class="headerlink" title="安装中文简体插件"></a>安装中文简体插件</h2><ol>
<li>点击左侧菜单栏最后一项<code>管理扩展</code>，在<strong>搜索框</strong>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</li>
<li>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后VS Code就显示中文了。</li>
</ol>
<h2 id="安装Go扩展"><a href="#安装Go扩展" class="headerlink" title="安装Go扩展"></a>安装Go扩展</h2><ol>
<li>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。</li>
<li>在<strong>搜索框</strong>中输入<code>Go</code> ，选中结果列表第一项，点击<code>install</code>安装。</li>
</ol>
<h2 id="安装Go语言开发工具包"><a href="#安装Go语言开发工具包" class="headerlink" title="安装Go语言开发工具包"></a>安装Go语言开发工具包</h2><p>安装Go语言开发工具包后，开发时我们可以获得代码提示、代码自动补全等功能。</p>
<ol>
<li>Windows平台按下<code>Ctrl+Shift+P</code>，Mac平台按<code>Command+Shift+P</code>，这个时候VS Code界面会弹出一个输入框。</li>
<li>在这个输入框中输入<code>&gt;go:install</code>，下面会自动搜索相关命令，选择<code>Go:Install/Update Tools</code>这个命令。</li>
<li>选择<strong>全部工具</strong>，并回车执行该命令。</li>
<li>VS Code此时会下载并安装列出来的16个工具，但是由于国内的网络环境基本上都会出现安装失败，各种<code>FAILED</code>。</li>
<li>我们可以手动从Github上下载工具，执行此步骤前提需要电脑上已经<strong>安装了Git</strong>。<ol>
<li>在自己的<code>GOPATH</code>的<code>src</code>目录下创建<code>golang.org/x</code>目录。</li>
<li>在<code>cmd</code>中<code>cd</code>到<code>GOPATH/src/golang.org/x</code>目录下。</li>
<li>执行<code>git clone https://github.com/golang/tools.git tools</code>命令。</li>
<li>执行<code>git clone https://github.com/golang/lint.git</code>命令。</li>
<li>按下<code>Ctrl+Shift+P</code>再次执行<code>Go:Install/Update Tools</code>命令，在弹出的窗口全选并点击确定，这一次的安装都会<code>SUCCESSED</code>了。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_01」搭建Go语言开发环境</title>
    <url>/2020/03/09/go-01/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://golang.org/dl/" target="_blank" rel="noopener">Go官网下载地址</a></p>
<p><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">Go官方镜像站（推荐）</a></p>
<h1 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h1><ol>
<li>安装Go语言环境；</li>
<li>在<code>cmd</code>窗口中输入<code>go version</code>来测试安装是否成功，输出<code>go version go1.14 windows/amd64</code>代表安装成功。</li>
</ol>
<h1 id="配置GOPATH"><a href="#配置GOPATH" class="headerlink" title="配置GOPATH"></a>配置GOPATH</h1><ul>
<li><code>GOPATH</code>是一个环境变量，用来表明Go语言项目保存的路径。</li>
<li><code>GOPATH</code>路径最好只设置一个，所有的项目代码都放到<code>GOPATH</code>的<code>src</code>路径下。</li>
<li>创建一个文件夹<code>.\Go</code>，创建一个环境变量，变量名为<code>GOPATH</code>，变量内容为这个文件夹的路径。</li>
<li>在 Go 1.8 版本之前，<code>GOPATH</code>环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后会为 <code>GOPATH</code>设置一个默认目录，参见下表，可以把自动创建的<code>GOPATH</code>变量删掉。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平台</th>
<th align="center">GOPATH默认值</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Windows</td>
<td align="center">%USERPROFILE%/go</td>
<td align="center">C:\Users\dodo\go</td>
</tr>
<tr>
<td align="center">Unix</td>
<td align="center">$HOME/go</td>
<td align="center">/home/dodo/go</td>
</tr>
</tbody></table>
<ul>
<li>在<code>GOPATH</code>目录下新建三个文件夹：<ul>
<li><code>bin</code>：用来存放编译后生成的可执行文件；</li>
<li><code>pkg</code>：用来存放编译后生成的归档文件；</li>
<li><code>src</code>：用来存放源码文件。</li>
</ul>
</li>
<li>把上面创建的<code>.\Go\bin</code>添加到系统的<code>PATH</code>环境变量中。</li>
<li>设置完环境变量后，<strong>重新打开一个</strong><code>cmd</code>，输入<code>go env</code>，可以查看Go语言的环境变量。其中<code>GOPATH</code>是要写代码的位置，<code>GOROOT</code>是安装Go语言环境的位置。</li>
</ul>
<h1 id="Go项目的目录结构"><a href="#Go项目的目录结构" class="headerlink" title="Go项目的目录结构"></a>Go项目的目录结构</h1><p>在进行Go语言开发的时候，我们的代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build</code>、<code>go install</code>或<code>go get</code>等指令后，会将下载的第三方包源代码文件放在<code>$GOPATH/src</code>目录下， 产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p>
<p>如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加<code>$GOPATH/src</code>目录的源代码即可。<code>bin</code> 和 <code>pkg</code> 目录的内容无需版本控制。</p>
<h2 id="适合个人开发者"><a href="#适合个人开发者" class="headerlink" title="适合个人开发者"></a>适合个人开发者</h2><p>我们知道源代码都是存放在<code>GOPATH</code>的<code>src</code>目录下，那我们可以按照下图来组织我们的代码。</p>
<p><img src="001.png" alt="001" title="001"></p>
<h2 id="目前流行的项目结构"><a href="#目前流行的项目结构" class="headerlink" title="目前流行的项目结构"></a>目前流行的项目结构</h2><p>Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用<code>顶级域名</code>来作为包名的前缀，这样就不担心项目名冲突的问题了。</p>
<p>因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。</p>
<p><img src="002.png" alt="002" title="002"></p>
<h2 id="适合企业开发场景"><a href="#适合企业开发场景" class="headerlink" title="适合企业开发场景"></a>适合企业开发场景</h2><p><img src="003.png" alt="003" title="003"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Python_02」第一部分：操作系统</title>
    <url>/2018/02/28/python1-02/</url>
    <content><![CDATA[<p>目标</p>
<ul>
<li>了解<strong>操作系统</strong>及作用</li>
</ul>
<h1 id="1-操作系统（Operation-System，OS）"><a href="#1-操作系统（Operation-System，OS）" class="headerlink" title="1. 操作系统（Operation System，OS）"></a>1. 操作系统（Operation System，OS）</h1><blockquote>
<p>操作系统作为接口的示意图</p>
</blockquote>
<p><img src="001.png" alt=""></p>
<blockquote>
<p>没有安装操作系统的计算机，通常被称为 <strong>裸机</strong></p>
<ul>
<li>如果想在 <strong>裸机</strong> 上运行自己所编写的程序，就必须用机器语言书写程序</li>
<li>如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，用高级语言开发程序</li>
</ul>
</blockquote>
<h2 id="1-1-操作系统的作用"><a href="#1-1-操作系统的作用" class="headerlink" title="1.1 操作系统的作用"></a>1.1 操作系统的作用</h2><ul>
<li>是现代计算机系统中 <strong>最基本和最重要</strong> 的系统软件</li>
<li>是 <strong>配置在计算机硬件上的第一层软件</strong>，是对硬件系统的首次扩展</li>
<li>主要作用是<strong>管理好硬件设备</strong>，并为用户和应用程序提供一个简单的接口，以便于使用</li>
<li>而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持</li>
</ul>
<h2 id="1-2-不同应用领域的主流操作系统"><a href="#1-2-不同应用领域的主流操作系统" class="headerlink" title="1.2 不同应用领域的主流操作系统"></a>1.2 不同应用领域的主流操作系统</h2><ul>
<li>桌面操作系统</li>
<li>服务器操作系统</li>
<li>嵌入式操作系统</li>
<li>移动设备操作系统</li>
</ul>
<h3 id="1-gt-桌面操作系统"><a href="#1-gt-桌面操作系统" class="headerlink" title="1&gt; 桌面操作系统"></a>1&gt; 桌面操作系统</h3><ul>
<li>Windows 系列<ul>
<li>用户群体大</li>
</ul>
</li>
<li>macOS<ul>
<li>适合于开发人员</li>
</ul>
</li>
<li>Linux<ul>
<li>应用软件少</li>
</ul>
</li>
</ul>
<h3 id="2-gt-服务器操作系统"><a href="#2-gt-服务器操作系统" class="headerlink" title="2&gt; 服务器操作系统"></a>2&gt; 服务器操作系统</h3><ul>
<li>Linux<ul>
<li>安全、稳定、免费</li>
<li>占有率高</li>
</ul>
</li>
<li>Windows Server<ul>
<li>付费</li>
<li>占有率低</li>
</ul>
</li>
</ul>
<p><img src="002.jpg" alt=""></p>
<h3 id="3-gt-嵌入式操作系统"><a href="#3-gt-嵌入式操作系统" class="headerlink" title="3&gt; 嵌入式操作系统"></a>3&gt; 嵌入式操作系统</h3><ul>
<li>Linux</li>
</ul>
<h3 id="4-gt-移动设备操作系统"><a href="#4-gt-移动设备操作系统" class="headerlink" title="4&gt; 移动设备操作系统"></a>4&gt; 移动设备操作系统</h3><ul>
<li>iOS</li>
<li>Android（基于 <code>Linux</code>）</li>
</ul>
<h2 id="1-3-虚拟机"><a href="#1-3-虚拟机" class="headerlink" title="1.3 虚拟机"></a>1.3 虚拟机</h2><p>虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统</p>
<ul>
<li>虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能</li>
<li>进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响</li>
<li>而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Python</tag>
        <tag>第一部分</tag>
      </tags>
  </entry>
  <entry>
    <title>「Python_01」第一部分：在虚拟机中安装Ubuntu</title>
    <url>/2018/02/28/python1-01/</url>
    <content><![CDATA[<h1 id="1-安装前的准备和基本安装"><a href="#1-安装前的准备和基本安装" class="headerlink" title="1. 安装前的准备和基本安装"></a>1. 安装前的准备和基本安装</h1><h2 id="1-1-安装前的准备"><a href="#1-1-安装前的准备" class="headerlink" title="1.1 安装前的准备"></a>1.1 安装前的准备</h2><ul>
<li>访问 <a href="http://cn.ubuntu.com/download/" target="_blank" rel="noopener">http://cn.ubuntu.com/download/</a> 下载 Ubuntu 16.04 版本</li>
<li>在操作系统上安装 <code>VMWare</code> 虚拟机软件</li>
</ul>
<blockquote>
<p>为什么要使用虚拟机？</p>
<ol>
<li>不需要准备 <strong>额外的电脑</strong></li>
<li>在虚拟机中可以 <strong>大胆尝试任何操作</strong>，不用担心造成不可逆转的破坏</li>
</ol>
</blockquote>
<h2 id="1-2-基本安装"><a href="#1-2-基本安装" class="headerlink" title="1.2 基本安装"></a>1.2 基本安装</h2><ul>
<li>有了映像文件之后，只需要按照提示一步一步操作即可安装 Ubuntu 了</li>
<li><strong>提示</strong>，在开始安装之前，请确认勾选了 <strong>在虚拟机中访问个人文件夹</strong>，如下图所示：</li>
</ul>
<p><img src="001.png" alt=""></p>
<blockquote>
<p>该选项可以方便地实现在 <strong>虚拟机</strong> 和 <strong>个人电脑</strong> 之间共享文件</p>
</blockquote>
<ul>
<li>安装结束后，登录并且进入系统，可以看到以下画面：</li>
</ul>
<p><img src="002.png" alt=""></p>
<h1 id="2-设置语言环境"><a href="#2-设置语言环境" class="headerlink" title="2. 设置语言环境"></a>2. 设置语言环境</h1><p>按照以下步骤操作可以修改 ubuntu 的语言环境</p>
<ul>
<li>1) 进入 <strong>系统设置 System Settings</strong></li>
<li>2) 打开 <strong>语言支持 Language Support</strong></li>
<li>3) 通过 <strong>安装/删除语言 Install/Remove Languages</strong> 添加 <strong>简体中文 Chinese(simplified)</strong></li>
<li>4) 将 <strong>汉语</strong> 拖拽到 <strong>顶部</strong>，如下图所示：</li>
</ul>
<p><img src="003.png" alt=""></p>
<ul>
<li>5) <strong>重新启动系统</strong></li>
<li>6) <strong>不</strong> 修改文件夹的名称，如下图所示：</li>
</ul>
<p><img src="004.png" alt=""></p>
<h1 id="3-安装常用软件"><a href="#3-安装常用软件" class="headerlink" title="3. 安装常用软件"></a>3. 安装常用软件</h1><ul>
<li>3.1 设置服务器镜像源</li>
<li>3.2 在启动栏添加 <strong>终端</strong> 图标</li>
<li>3.3 <strong>apt</strong> 终端命令</li>
<li>3.4 谷歌浏览器 chrome</li>
<li>3.5 搜狗输入法</li>
</ul>
<h2 id="3-1-设置服务器镜像源"><a href="#3-1-设置服务器镜像源" class="headerlink" title="3.1 设置服务器镜像源"></a>3.1 设置服务器镜像源</h2><ul>
<li>Ubuntu 中 <strong>大部分</strong> 的软件 <strong>安装/更新</strong> 都是利用 <code>apt</code> 命令，从 <strong>ubuntu 的服务器</strong> 直接安装的</li>
<li>Ubuntu <strong>官方的服务器在国外</strong>，为了提高软件 <strong>安装/更新速度</strong>，<strong>ubuntu</strong> 提供了 <strong>选择最佳服务器</strong> 的功能，可以帮助我们方便的找到一个速度最快的 <strong>镜像服务器</strong>！</li>
</ul>
<blockquote>
<p>所谓 <strong>镜像服务器</strong>，就是 <strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，速度不同，通常国内服务器速度会更快一些！</p>
</blockquote>
<p>按照以下步骤操作可以设置 ubuntu 的服务器</p>
<ul>
<li>1) 进入 <strong>系统设置</strong></li>
<li>2) 打开 <strong>软件和更新</strong></li>
<li>3) 设置 <strong>下载自…</strong> <strong>其他站点</strong></li>
<li>4) 通过 <strong>选择最佳服务器</strong> 选择速度最快的 <strong>镜像源</strong>，如下图所示：</li>
</ul>
<p><img src="005.png" alt=""></p>
<p><strong>提示</strong>：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</p>
<h2 id="3-2-在启动栏添加-终端-图标"><a href="#3-2-在启动栏添加-终端-图标" class="headerlink" title="3.2 在启动栏添加 终端 图标"></a>3.2 在启动栏添加 <strong>终端</strong> 图标</h2><ul>
<li>Ubuntu 的 <strong>启动栏</strong> 类似于 Windows 的 <strong>任务栏</strong>，可以显示 <strong>常用软件图标</strong> 和 <strong>正在运行的软件图标</strong></li>
<li>通常 Linux 的用户使用 <strong>终端命令</strong> 的频率非常高，所以会把 <strong>终端</strong> 添加到 <strong>启动栏</strong></li>
<li>通过最上方的 <strong>搜索</strong> 按钮可以 <strong>搜索并启动</strong> 需要使用的程序</li>
<li><strong>点击右键</strong> 可以 <strong>保留</strong>、<strong>删除</strong> 或者 <strong>移动</strong> 启动栏中图标</li>
<li>可以把最常用的软件图标，<strong>保留</strong> 在启动栏，可以方便快速启动程序</li>
</ul>
<h2 id="3-3-apt-终端命令"><a href="#3-3-apt-终端命令" class="headerlink" title="3.3 apt 终端命令"></a>3.3 apt 终端命令</h2><ul>
<li><code>apt</code> 是 <code>Advanced Packaging Tool</code>，是 Ubuntu 下的 <strong>安装包管理工具</strong></li>
<li><strong>大部分</strong> 的软件 <strong>安装/更新/卸载</strong> 都是利用 <code>apt</code> 命令来实现的</li>
<li>直接在终端中输入 <code>apt</code> 即可以查阅命令的帮助信息</li>
<li>常用命令如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 安装软件</span></span><br><span class="line">$ sudo apt install 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 卸载软件</span></span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 更新可用软件包列表</span></span><br><span class="line">$ sudo apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 更新已安装的包</span></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>

<h3 id="1-软件更新和升级"><a href="#1-软件更新和升级" class="headerlink" title="1) 软件更新和升级"></a>1) 软件更新和升级</h3><ul>
<li>通常安装完 ubuntu 之后，可以先使用 <code>upgrade</code> 更新一下当前系统中可以升级的的软件包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line"></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>提示</strong> 如果增加、更换了软件源，通常需要使用 <code>update</code> 更新一下本地缓存</li>
</ul>
<h3 id="2-安装常用工具"><a href="#2-安装常用工具" class="headerlink" title="2) 安装常用工具"></a>2) 安装常用工具</h3><p><strong>提示</strong> apt 安装命令的格式是不需要记忆的，如果在终端中输入的软件没有安装，系统会提示 <strong>apt 命令</strong> 的使用格式</p>
<h4 id="python-程序员"><a href="#python-程序员" class="headerlink" title="python 程序员"></a>python 程序员</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install ipython</span><br><span class="line">$ sudo apt install ipython3</span><br><span class="line">$ sudo apt install python-pip</span><br><span class="line">$ sudo apt install python3-pip</span><br></pre></td></tr></table></figure>

<h4 id="C-程序员"><a href="#C-程序员" class="headerlink" title="C++ 程序员"></a>C++ 程序员</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install cmake</span><br><span class="line">$ sudo apt install qtcreator</span><br></pre></td></tr></table></figure>

<h4 id="ruby-程序员"><a href="#ruby-程序员" class="headerlink" title="ruby 程序员"></a>ruby 程序员</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install ruby</span><br></pre></td></tr></table></figure>

<h4 id="安装-ssh-服务器"><a href="#安装-ssh-服务器" class="headerlink" title="安装 ssh 服务器"></a>安装 ssh 服务器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure>

<p>安装之后，才可以在其他系统中，通过 ssh 工具远程登陆</p>
<h3 id="3-删除不使用的软件"><a href="#3-删除不使用的软件" class="headerlink" title="3) 删除不使用的软件"></a>3) 删除不使用的软件</h3><p><strong>libreoffice</strong></p>
<ul>
<li><code>libreoffice</code> 是一套类似于 <code>微软 Office</code> 的 <strong>免费的</strong> 办公套件</li>
<li>不过无论是界面交互还是执行性能都还有很大的提升空间</li>
<li>卸载 libreoffice 可以释放大概 <strong>300M</strong> 的磁盘空间</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt remove libreoffice-common</span><br></pre></td></tr></table></figure>

<p><strong>Amazon</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt remove unity-webapps-common</span><br></pre></td></tr></table></figure>

<h3 id="4-扩展：apt-和-apt-get"><a href="#4-扩展：apt-和-apt-get" class="headerlink" title="4) 扩展：apt 和 apt-get"></a>4) 扩展：<code>apt</code> 和 <code>apt-get</code></h3><ul>
<li><code>apt</code> 和 <code>apt-get</code> 都是 ubuntu 下常用的安装软件的命令</li>
<li><strong>早期</strong> 使用 <code>apt-get</code>，从 ununtu 16 开始，官方建议使用 <code>apt</code></li>
<li>这两个命令的 <strong>使用方式非常类似</strong></li>
</ul>
<h2 id="3-4-deb-安装格式"><a href="#3-4-deb-安装格式" class="headerlink" title="3.4 deb 安装格式"></a>3.4 deb 安装格式</h2><p><strong>deb</strong> 是 Debian Linux 的安装格式，在 ubuntu 中同样可以使用。要安装 deb 安装包，需要使用 <code>dpkg</code> 这个终端命令，命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg -i &lt;package.deb&gt;</span><br></pre></td></tr></table></figure>

<h3 id="1-谷歌浏览器"><a href="#1-谷歌浏览器" class="headerlink" title="1) 谷歌浏览器"></a>1) 谷歌浏览器</h3><ol>
<li>从 <a href="https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb" target="_blank" rel="noopener">https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</a> 下载最新版本的安装文件</li>
<li>在终端中执行以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install libappindicator1 libindicator7</span><br><span class="line">$ sudo dpkg -i google-chrome-stable_current_amd64.deb   </span><br><span class="line">$ sudo apt -f install</span><br></pre></td></tr></table></figure>

<h3 id="2-搜狗输入法"><a href="#2-搜狗输入法" class="headerlink" title="2) 搜狗输入法"></a>2) 搜狗输入法</h3><p><strong>fcitx</strong> 被称为 <strong>小企鹅输入法</strong>，是一个以 GPL 方式发布的 <strong>输入法平台</strong>，可以通过安装引擎支持多种输入法。它的优点是，短小精悍、跟程序的兼容性比较好！</p>
<ol>
<li>打开 <strong>系统设置</strong> <strong>语言支持</strong><ul>
<li>将 <strong>键盘输入法系统</strong> 修改为 <strong>fcitx</strong></li>
</ul>
</li>
<li>访问网站 <a href="http://pinyin.sogou.com/linux/" target="_blank" rel="noopener">http://pinyin.sogou.com/linux/</a> 下载最新版本的安装文件</li>
<li>在终端中执行以下命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb</span><br><span class="line">$ sudo apt -f install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示，安装输入法之后，需要重新启动系统</p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Python</tag>
        <tag>第一部分</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_06」梯度下降法</title>
    <url>/2017/03/13/ai-lhyML-06/</url>
    <content><![CDATA[<h1 id="复习-梯度下降法"><a href="#复习-梯度下降法" class="headerlink" title="复习 | 梯度下降法"></a>复习 | 梯度下降法</h1><p>在回归问题的第三步中，需要解决下面的最优化问题：</p>
<p>$$<br>\theta^* = \arg \min_\theta L(\theta)<br>$$</p>
<ul>
<li>$L$ ：lossfunction（损失函数）</li>
<li>$\theta$ ：parameters（参数）</li>
</ul>
<p>这里的 $\theta$ 指代一堆参数，比如上篇说到的 $w$ 和 $b$ 。</p>
<p>我们要找一组参数 $\theta$ ，让损失函数越小越好，这个问题可以用梯度下降法解决：</p>
<p>假设 $\theta$ 有里面有两个参数 $\theta_1, \theta_2$，随机选取初始值</p>
<ol>
<li>随机地选择一个起始的$\theta$</li>
</ol>
<p>$$<br>\theta^0 = \left[<br>\begin{matrix}<br>\theta_1^0 \\<br>\theta_2^0<br>\end{matrix}<br>\right]<br>$$</p>
<ol start="2">
<li>计算下一个点的坐标</li>
</ol>
<p>$$<br>\left[<br>\begin{matrix}<br>\theta_1^1 \\<br>\theta_2^1<br>\end{matrix}<br>\right] = \left[<br>\begin{matrix}<br>\theta_1^0 \\<br>\theta_2^0<br>\end{matrix}<br>\right] - \eta \left[<br>\begin{matrix}<br>\frac{\partial L(\theta_1^0)}{\partial \theta_1} \\<br>\frac{\partial L(\theta_2^0)}{\partial \theta_2}<br>\end{matrix}<br>\right]<br>$$</p>
<ol start="3">
<li>反复进行.</li>
</ol>
<blockquote>
<p>梯度表示为<br>$$<br>\nabla L(\theta) = \left[<br>\begin{matrix}<br>\frac{\partial C(\theta_1)}{\partial \theta_1} \\<br>\frac{\partial C(\theta_2)}{\partial \theta_2}<br>\end{matrix}<br>\right]<br>$$</p>
</blockquote>
<p>那么点的更新过程就可以写成：</p>
<p>$$<br>\theta^1 = \theta^0 - \eta \nabla L(\theta^0)<br>$$</p>
<p>$$<br>\theta^2 = \theta^1 - \eta \nabla L(\theta^1)<br>$$</p>
<p>下图举例将梯度下降法的计算过程进行可视化。</p>
<p><img src="chapter6-2.png" alt=""></p>
<h1 id="提示一-小心调整步长"><a href="#提示一-小心调整步长" class="headerlink" title="提示一 | 小心调整步长"></a>提示一 | 小心调整步长</h1><p>举例：</p>
<p><img src="chapter6-3.png" alt=""></p>
<p>上图左边黑色为损失函数的曲线，假设从左边最高点开始，如果学习率调整的刚刚好，比如红色的线，就能顺利找到最低点。</p>
<ul>
<li>如果学习率调整的太小，比如蓝色的线，就会走的太慢，虽然这种情况给足够多的时间也可以找到最低点，实际情况可能会等不及出结果。</li>
<li>如果学习率调整的有点大，比如绿色的线，就会在上面震荡，走不下去，永远无法到达最低点。</li>
<li>还有可能非常大，比如黄色的线，直接就飞出去了，更新参数的时候只会发现损失函数越更新越大。</li>
</ul>
<p>虽然这样的可视化可以很直观观察，但可视化也只是能在参数是一维或者二维的时候进行，更高维的情况已经无法可视化了。</p>
<p>解决方法就是上图右边的方案，将<strong>参数改变对损失函数的影响进行可视化</strong>。</p>
<ul>
<li>比如学习率太小（蓝色的线），损失函数下降的非常慢；</li>
<li>学习率太大（绿色的线），损失函数下降很快，但马上就卡住不下降了；</li>
<li>学习率特别大（黄色的线），损失函数就飞出去了；</li>
<li>红色的就是差不多刚好，可以得到一个好的结果。</li>
</ul>
<h2 id="自适应学习率"><a href="#自适应学习率" class="headerlink" title="自适应学习率"></a>自适应学习率</h2><ul>
<li>一种常用的做法：<strong>每隔几次迭代就减小步长</strong>.<ul>
<li>最开始的时候，我们距离最优点很远，所以我们可以使用很大的步长.</li>
<li>经过若干次迭代后，我们距离最优点很近了，所以我们要减小步长.</li>
<li>例如：$\frac{1}{t}$衰减，$\eta^t = \frac{\eta}{\sqrt{t+1}}$，其中$t$代表迭代次数.</li>
</ul>
</li>
<li>步长的选择是不可能一劳永逸的.<ul>
<li>最好的做法是，<strong>每个参数选择不同的步长</strong>. </li>
</ul>
</li>
</ul>
<h2 id="Adagrad-算法"><a href="#Adagrad-算法" class="headerlink" title="Adagrad 算法"></a>Adagrad 算法</h2><h3 id="Adagrad-是什么"><a href="#Adagrad-是什么" class="headerlink" title="Adagrad 是什么"></a>Adagrad 是什么</h3><p>将每一个参数的步长都除以它之前导数的均方根。</p>
<p><strong>普通的</strong>批次梯度下降（Vanilla Gradient descent）的做法：<br>$$<br>w^{t+1} \leftarrow  w^t -η^tg^t<br>$$</p>
<p>$$<br>\eta^t =\frac{\eta^t}{\sqrt{t+1}}<br>$$</p>
<hr>
<p>Adagrad可以做的更好：<br>$$<br>w^{t+1} \leftarrow  w^t -\frac{η^t}{\sigma^t}g^t<br>$$</p>
<p>$$<br>g^t =\frac{\partial L(\theta^t)}{\partial w}<br>$$</p>
<ul>
<li>$w$：是其中一个参数，因为改进的算法要针对每个参数选择不同的步长.</li>
<li>$\sigma^t$：参数$w$的前一个导数的均方根.</li>
<li>$\eta^t = \frac{\eta}{\sqrt{t+1}}$.</li>
<li>$g^t = \frac{\partial C(\theta^t)}{\partial w}$.</li>
</ul>
<p>这样以来，每次参数的更新都是依赖于每个参数的不同梯度。</p>
<h3 id="Adagrad举例"><a href="#Adagrad举例" class="headerlink" title="Adagrad举例"></a>Adagrad举例</h3><p>下面是一个参数的更新过程</p>
<p>$$<br>w^1 \leftarrow w^0 - \frac{\eta^0}{\sigma^0} g^0 , \sigma^0 = \sqrt{(g^0)^2}<br>$$</p>
<p>$$<br>w^2 \leftarrow w^1 - \frac{\eta^1}{\sigma^1} g^1 , \sigma^1 = \sqrt{\frac{1}{2}[(g^0)^2+(g^1)^2]}<br>$$</p>
<p>$$<br>w^3 \leftarrow w^2 - \frac{\eta^2}{\sigma^2} g^2 , \sigma^2 = \sqrt{\frac{1}{3}[(g^0)^2+(g^1)^2+(g^2)^2]}<br>$$</p>
<p>$$<br>\dots \dots<br>$$</p>
<p>$$<br>w^{t+1} \leftarrow w^t - \frac{\eta^t}{\sigma^t} g^t , \sigma^t = \sqrt{\frac{1}{t+1} \sum_{i=0}^{t}(g^i)^2}<br>$$</p>
<p>将$\eta^t$和$\sigma^t$的表达式代入到式中，上下同时消去$\frac{1}{\sqrt{t+1}}$得：</p>
<p>$$<br>w^{t+1} \leftarrow w^t - \frac{\eta}{\sqrt{\sum_{i=0}^{t}(g^i)^2}} g^t<br>$$</p>
<h2 id="Adagrad存在的矛盾"><a href="#Adagrad存在的矛盾" class="headerlink" title="Adagrad存在的矛盾"></a>Adagrad存在的矛盾</h2><p><img src="chapter6-6.png" alt=""></p>
<p>在 Adagrad中，当梯度越大的时候，步伐应该越大，但下面分母又导致当梯度越大的时候，步伐会越小。</p>
<p>下图是一个直观的解释：</p>
<p><img src="chapter6-7.png" alt=""></p>
<p>$g^4$的反差特别小。</p>
<p>分母$\sqrt{\sum_{i=0}^{t}(g^i)^2}$就表示了造成反差的效果。</p>
<hr>
<p>下面给一个正式的解释：</p>
<p><img src="chapter6-8.png" alt=""></p>
<p>比如初始点在 $x_0$，最低点为 $−\frac{b}{2a}$，最佳的步伐就是 $x0$ 到最低点之间的距离 $\left | x_0+\frac{b}{2a} \right |$，也可以写成 $\left | \frac{2ax_0+b}{2a} \right |$。而刚好 $|2ax_0+b|$ 就是方程绝对值在 $x_0$ 这一点的微分。</p>
<p>这样可以认为如果算出来的微分越大，则距离最低点越远。而且最好的步伐和微分的大小成正比。所以如果踏出去的步伐和微分成正比，它可能是比较好的。</p>
<p>结论：梯度越大，就跟最低点的距离越远。</p>
<p>这个结论在多个参数的时候就不一定成立了。</p>
<h2 id="多参数下结论不一定成立"><a href="#多参数下结论不一定成立" class="headerlink" title="多参数下结论不一定成立"></a>多参数下结论不一定成立</h2><p>对比不同的参数</p>
<p><img src="chapter6-9.png" alt=""></p>
<p>上图左边是两个参数的损失函数，颜色代表损失函数的值。如果只考虑参数 $w_1$，就像图中蓝色的线，得到右边上图结果；如果只考虑参数 $w_2$，就像图中绿色的线，得到右边下图的结果。确实对于 $a$ 和 $b$，结论1-1是成立的，同理 $c$ 和 $b$ 也成立。但是如果对比$a$ 和 $c$，就不成立了，$c$ 比 $a$ 大，但 $c$ 距离最低点是比较近的。</p>
<p>所以上面的结论是在没有考虑跨参数对比的情况下，才能成立的。所以还不完善。</p>
<p>之前说到的最佳距离 $\left | \frac{2ax_0+b}{2a} \right |$，还有个分母 $2a$ 。对function进行二次微分刚好可以得到：</p>
<p>$$<br>\frac{\partial ^2y}{\partial x^2} = 2a<br>$$</p>
<p>所以最好的步伐应该是：</p>
<p>$$<br>\frac{一次微分}{二次微分}<br>$$</p>
<p>即不止和一次微分成正比，还和二次微分成反比。最好的step应该考虑到二次微分：</p>
<p><img src="chapter6-10.png" alt=""></p>
<h2 id="Adagrad进一步的解释"><a href="#Adagrad进一步的解释" class="headerlink" title="Adagrad进一步的解释"></a>Adagrad进一步的解释</h2><p>再回到之前的 Adagrad</p>
<p><img src="chapter6-11.png" alt=""></p>
<p>对于 $\sqrt{\sum_{i=0}^t(g^i)^2}$ 就是希望再尽可能不增加过多运算的情况下模拟二次微分。（如果计算二次微分，在实际情况中可能会增加很多的时间消耗）</p>
<h1 id="提示二-随机梯度下降法"><a href="#提示二-随机梯度下降法" class="headerlink" title="提示二 | 随机梯度下降法"></a>提示二 | 随机梯度下降法</h1><p>原来的梯度下降方法：</p>
<ul>
<li>损失函数的计算：</li>
</ul>
<p>$$<br>L = \sum_{n} \left(\hat{y}^n - \left(b + \sum w_i x_i^n\right)\right)^2<br>$$</p>
<ul>
<li>点的更新：</li>
</ul>
<p>$$<br>\theta^i = \theta^{i-1} - \eta \nabla L(\theta^{i-1})<br>$$</p>
<p>而随机梯度下降法（Stochastic Gradient Descent）：</p>
<ul>
<li>选择一个样本$x^n$.</li>
<li>只计算选择的样本$x^n$的损失函数：</li>
</ul>
<p>$$<br>L^n = \left( \hat{y}^n - \left( b + \sum w_i x_i^n \right) \right)^2<br>$$</p>
<ul>
<li>根据样本$x^n$的损失函数来更新点：</li>
</ul>
<p>$$<br>\theta^i = \theta^{i-1} - \eta \nabla L^n(\theta^{i-1})<br>$$</p>
<p>这样，在原来的梯度下降法看了全部样本之前，就可以看一个样本走一步，最后得到解.</p>
<p>对比：</p>
<p><img src="chapter6-12.png" alt=""></p>
<p>常规梯度下降法走一步要处理到所有二十个例子，但随机算法此时已经走了二十步（每处理一个例子就更新）</p>
<h1 id="提示三-特征缩放"><a href="#提示三-特征缩放" class="headerlink" title="提示三 | 特征缩放"></a>提示三 | 特征缩放</h1><p>比如有个函数：</p>
<p>$$<br>y = b + w_1 x_1 + w_2 x_2<br>$$</p>
<p>当中，$x_1$和$x_2$的尺度不同，那么就要进行特征放缩，让特征拥有相同的尺度。</p>
<p><img src="chapter6-13.png" alt=""></p>
<h2 id="为什么要这样做"><a href="#为什么要这样做" class="headerlink" title="为什么要这样做"></a>为什么要这样做</h2><p><img src="chapter6-14.png" alt=""></p>
<p>上图左边是 $x_1$ 的scale比 $x_2$ 要小很多，所以当 $w_1$ 和 $w_2$ 做同样的变化时，$w_1$ 对 $y$ 的变化影响是比较小的，$x_2$ 对 $y$ 的变化影响是比较大的。</p>
<p>坐标系中是两个参数的error surface（现在考虑左边蓝色），因为 $w_1$ 对 $y$ 的变化影响比较小，所以 $w_1$ 对损失函数的影响比较小，$w_1$ 对损失函数有比较小的微分，所以 $w_1$ 方向上是比较平滑的。同理 $x_2$ 对 $y$ 的影响比较大，所以 $x_2$ 对损失函数的影响比较大，所以在 $x_2$ 方向有比较尖的峡谷。</p>
<p>上图右边是两个参数scaling比较接近，右边的绿色图就比较接近圆形。</p>
<p>对于左边的情况，上面讲过这种狭长的情形不过不用Adagrad的话是比较难处理的，两个方向上需要不同的学习率，同一组学习率会搞不定它。而右边情形更新参数就会变得比较容易。左边的梯度下降并不是向着最低点方向走的，而是顺着等高线切线法线方向走的。但绿色就可以向着圆心（最低点）走，这样做参数更新也是比较有效率。</p>
<h2 id="怎么做缩放"><a href="#怎么做缩放" class="headerlink" title="怎么做缩放"></a>怎么做缩放</h2><p>方法非常多，这里举例一种常见的做法：</p>
<p><img src="chapter6-15.png" alt=""></p>
<p>对于每一个维度$i$的特征，计算：</p>
<ol>
<li>均值：</li>
</ol>
<p>$$<br>m_i = \frac{1}{R} \sum^{R}_{j=1} x_i^j<br>$$</p>
<ol start="2">
<li>标准差：</li>
</ol>
<p>$$<br>\sigma_i = \frac{1}{R}\sum_{j=1}^{R} \left( x_i^j - m_i \right)^2<br>$$</p>
<ol start="3">
<li>计算尺度变换后的特征：</li>
</ol>
<p>$$<br>x_i^r = \dfrac{x_i^r - m_i}{\sigma_i}<br>$$</p>
<p>这样得到的新的特征<strong>均值为0，方差为1</strong>.</p>
<h1 id="梯度下降的理论基础"><a href="#梯度下降的理论基础" class="headerlink" title="梯度下降的理论基础"></a>梯度下降的理论基础</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当用梯度下降解决问题：</p>
<p>$$<br>\theta^∗= \underset{ \theta }{\operatorname{arg\ max}}  L(\theta)<br>$$</p>
<p>每次更新参数 $\theta$，都得到一个新的 $\theta$，它都使得损失函数更小。即：</p>
<p>$$<br>L(\theta^0) &gt;L(\theta^1)&gt;L(\theta^2)&gt;\dots<br>$$</p>
<p>上述结论正确吗？</p>
<p>结论是不正确的。</p>
<h2 id="数学理论"><a href="#数学理论" class="headerlink" title="数学理论"></a>数学理论</h2><p><img src="chapter6-16.png" alt=""></p>
<p>比如在 $\theta^0$ 处，可以在一个小范围的圆圈内找到损失函数细小的 $\theta^1$，不断的这样去寻找。</p>
<hr>
<p>接下来就是如果在小圆圈内快速的找到最小值？</p>
<h2 id="泰勒展开式"><a href="#泰勒展开式" class="headerlink" title="泰勒展开式"></a>泰勒展开式</h2><p>先介绍一下泰勒展开式</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>若 $h(x)$ 在 $x=x_0$ 点的某个领域内有无限阶导数（即无限可微分，infinitely differentiable），那么在此领域内有：</p>
<p>$$<br>\begin{aligned}<br>h(x)  &amp;= \sum_{k=0}^{\infty }\frac{h^k(x_0)}{k!}(x-x_0)^k  \<br>&amp; =h(x_0)+{h}’(x_0)(x−x_0)+\frac{h’’(x_0)}{2!}(x−x_0)^2+⋯<br>\end{aligned}<br>$$</p>
<p>当 $x$ 很接近 $x_0$ 时，有 $h(x)≈h(x_0)+{h}’(x_0)(x−x_0)$，式就是函数 $h(x)$ 在 $x=x_0$ 点附近关于 $x$ 的幂函数展开式，也叫泰勒展开式。</p>
<p>举例：</p>
<p><img src="chapter6-17.png" alt=""></p>
<p>图中3条蓝色线是把前3项作图，橙色线是 $sin(x)$。</p>
<h3 id="多变量泰勒展开式"><a href="#多变量泰勒展开式" class="headerlink" title="多变量泰勒展开式"></a>多变量泰勒展开式</h3><p>下面是两个变量的泰勒展开式</p>
<p><img src="chapter6-18.png" alt=""></p>
<h2 id="利用泰勒展开式简化"><a href="#利用泰勒展开式简化" class="headerlink" title="利用泰勒展开式简化"></a>利用泰勒展开式简化</h2><p>回到之前如何快速在圆圈内找到最小值。基于泰勒展开式，在 $(a,b)$ 点的红色圆圈范围内，可以将损失函数用泰勒展开式进行简化：</p>
<p><img src="chapter6-19.png" alt=""></p>
<p>将问题进而简化为下图：</p>
<p><img src="chapter6-20.png" alt=""></p>
<p>不考虑s的话，可以看出剩下的部分就是两个向量$(\triangle \theta_1,\triangle \theta_2)$ 和  $(u,v)$ 的内积，那怎样让它最小，就是和向量 $(u,v)$ 方向相反的向量</p>
<p><img src="chapter6-21.png" alt=""></p>
<p>然后将u和v带入。</p>
<p><img src="chapter6-22.png" alt=""></p>
<p>$$<br>L(\theta)\approx s+u(\theta_1 - a)+v(\theta_2 - b)<br>$$</p>
<p>发现最后的式子就是梯度下降的式子。但这里用这种方法找到这个式子有个前提，泰勒展开式给的损失函数的估算值是要足够精确的，而这需要红色的圈圈足够小（也就是学习率足够小）来保证。所以理论上每次更新参数都想要损失函数减小的话，即保证式1-2 成立的话，就需要学习率足够足够小才可以。</p>
<p>所以实际中，当更新参数的时候，如果学习率没有设好，是有可能式1-2是不成立的，所以导致做梯度下降的时候，损失函数没有越来越小。</p>
<p>式1-2只考虑了泰勒展开式的一次项，如果考虑到二次项（比如牛顿法），在实际中不是特别好，会涉及到二次微分等，多很多的运算，性价比不好。</p>
<h1 id="梯度下降的限制"><a href="#梯度下降的限制" class="headerlink" title="梯度下降的限制"></a>梯度下降的限制</h1><p><img src="chapter6-23.png" alt=""></p>
<ul>
<li>容易陷入局部极值；</li>
<li>还有可能卡在不是极值，但微分值是0的地方；</li>
<li>还有可能实际中只是当微分值小于某一个数值就停下来了，但这里只是比较平缓，并不是极值点。</li>
</ul>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="AOE中的示例"><a href="#AOE中的示例" class="headerlink" title="AOE中的示例"></a>AOE中的示例</h2><ul>
<li>利用<strong>帝国时代</strong>的方式模拟<strong>梯度下降</strong>；</li>
<li>在地图上大多数位置我们是未知的，只有我们单位走过的地方是可知；</li>
<li>地图上的海拔可以看作损失函数<strong>loss function</strong>，我们的目的就是寻找海拔的最低点的值；</li>
<li>随机初始一个位置，朝向较低的方向移动，周而复始，直到<strong>local minimal</strong>(在不开天眼的情况下，你始终不会知晓所在位置是否为global minimal)。</li>
</ul>
<h2 id="Minecraft中的示例"><a href="#Minecraft中的示例" class="headerlink" title="Minecraft中的示例"></a>Minecraft中的示例</h2><ul>
<li>利用<strong>梯度下降法</strong>更新参数，损失函数loss function可能会不降反升(利用<strong>Mincraft</strong>解释该情况)；</li>
<li>人物的前方是较低方向，右方也是较低方向，利用梯度下降法，往右前方移动一步，然后反复用梯度下降法，往右前方移动一步，周而复始；</li>
<li>尽管前方和右方是下降的方向，但往右前方移动，将会失败(因为实际右前方是比较高的地方)。</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_05」误差的来源</title>
    <url>/2017/03/13/ai-lhyML-05/</url>
    <content><![CDATA[<p><img src="chapter5-1.png" alt=""></p>
<p>从上节课测试集数据来看，Average Error随着模型复杂增加呈指数上升趋势，更复杂的模型并不能给测试集带来更好的效果。</p>
<p>而这些Error的主要有<strong>两个来源</strong>，分别是<strong>bias（偏差）和variance（方差）</strong>。</p>
<p><img src="001.jpg" alt=""></p>
<h1 id="估测"><a href="#估测" class="headerlink" title="估测"></a>估测</h1><p>假设真实的模型为 $\hat f$ ， 如果我们知道 $\hat f$ 模型，那是最好不过了，但是 $\hat f$ 只有 Niamtic 公司才知道。</p>
<p><img src="chapter5-2.png" alt=""></p>
<p>所以我们只能通过收集 Pokemon精灵 的数据，然后通过 step1~step3 训练得到我们的理想模型 $f^<em>$，$f^</em>$ 其实是  $\hat f$ 的一个预估。</p>
<p><img src="chapter5-3.png" alt=""></p>
<p>这个过程就像打靶，$\hat f$ 就是我们的靶心，$f^<em>$ 就是我们投掷的结果。如上图所示，$\hat f$ 与  $f^</em>$ 之间蓝色部分的差距就是偏差和方差导致的。</p>
<h2 id="估测变量x的偏差和方差"><a href="#估测变量x的偏差和方差" class="headerlink" title="估测变量x的偏差和方差"></a>估测变量x的偏差和方差</h2><h3 id="估测x的偏差"><a href="#估测x的偏差" class="headerlink" title="估测x的偏差"></a>估测x的偏差</h3><ul>
<li>假设 $x$ 的平均值是  $\mu$，方差为 $\sigma^2$</li>
</ul>
<p>评估平均值要怎么做呢？</p>
<ul>
<li><p>首先拿到 $N$ 个样本点：${x^1,x^2,···,x^N}$</p>
</li>
<li><p>计算平均值 $m$, 得到</p>
</li>
</ul>
<p>$$<br>m = \frac{1}{N} \sum_{n} x^n \neq \mu<br>$$</p>
<p><img src="chapter5-4.png" alt=""></p>
<p>但是如果计算很多组的 $m$ ，然后求 $m$ 的期望：</p>
<p>$$<br>E[m]=E\left[\frac{1}{N}\sum x^n\right]=\frac{1}{N}\sum_nE\left[x^n\right]=\mu<br>$$</p>
<p>这个估计是<strong>无偏估计（unbiased）</strong>。</p>
<p>然后 $m$ 分布对于 $\mu$ 的离散程度（方差）：</p>
<p>$$<br>Var[m]=\frac{\sigma^2}{N}<br>$$</p>
<p>这个取决于 $N$，下图看出 $N$ 越小越离散：</p>
<p><img src="chapter5-5.png" alt=""></p>
<h3 id="估测变量x的方差"><a href="#估测变量x的方差" class="headerlink" title="估测变量x的方差"></a>估测变量x的方差</h3><p>如何估算方差呢？</p>
<p>首先根据前一节计算出来很多个$m$，然后计算每个值对应的$s^2$<br>$$<br>s^2 = \frac{1}{N} \sum_{n} \left( x^n - m \right) ^2<br>$$</p>
<p>而后计算$s^2$的期望值<br>$$<br>E\left[ s^2 \right] = \frac{N-1}{N} \sigma^2<br>$$</p>
<p>说明普遍而言，$s$要比$\sigma$的值小，这是<strong>有偏差的估计</strong>。</p>
<p><img src="chapter5-6.png" alt=""></p>
<p>增大$N$的值，那么$s$和$\sigma$之间估测的差距就会变小。</p>
<p><img src="chapter5-7.png" alt=""></p>
<h2 id="为什么会有很多的模型"><a href="#为什么会有很多的模型" class="headerlink" title="为什么会有很多的模型?"></a>为什么会有很多的模型?</h2><p>讨论系列02中的案例：这里假设是在平行宇宙中，抓了不同的神奇宝贝</p>
<p><img src="chapter5-8.png" alt=""></p>
<p>用同一个model，在不同的训练集中找到的 $f^∗$ 就是不一样的</p>
<p><img src="chapter5-9.png" alt=""></p>
<p>这就像在靶心上射击，进行了很多组（一组多次）。现在需要知道它的散布是怎样的，将100个宇宙中的model画出来</p>
<p><img src="chapter5-10.png" alt=""></p>
<p>不同的数据集之前什么都有可能发生。</p>
<h3 id="考虑不同模型的方差"><a href="#考虑不同模型的方差" class="headerlink" title="考虑不同模型的方差"></a>考虑不同模型的方差</h3><p>一次模型的方差就比较小的，也就是是比较集中，离散程度较小。而5次模型的方差就比较大，同理散布比较广，离散程度较大。</p>
<p>所以用比较简单的模型，方差是比较小的（就像射击的时候每次的时候，每次射击的设置都集中在一个比较小的区域内）。如果用了复杂的模型，方差就很大，散布比较开。</p>
<p>这也是因为简单的模型受到不同训练集的影响是比较小的。</p>
<h3 id="考虑不同模型的偏差"><a href="#考虑不同模型的偏差" class="headerlink" title="考虑不同模型的偏差"></a>考虑不同模型的偏差</h3><p><img src="chapter5-11.png" alt=""></p>
<p>这里没办法知道真正的 $\hat{f}$，所以假设图中的那条黑色曲线为真正的 $\hat{f}$</p>
<p>结果可视化，一次平均的 $\bar{f}$ 没有5次的好，虽然5次的整体结果离散程度很高。</p>
<p>一次模型的偏差比较大，而复杂的5次模型，偏差就比较小。</p>
<p><img src="002.png" alt=""></p>
<p>直观的解释：简单的模型函数集的space比较小，所以可能space里面就没有包含靶心，肯定射不中。而复杂的模型函数集的space比较大，可能就包含的靶心，只是没有办法找到确切的靶心在哪，但足够多的，就可能得到真正的function。</p>
<h3 id="偏差v-s-方差"><a href="#偏差v-s-方差" class="headerlink" title="偏差v.s.方差"></a>偏差v.s.方差</h3><p><img src="chapter5-12.png" alt=""></p>
<p>将系列02中的误差拆分为偏差和方差。</p>
<ul>
<li>简单模型（左边）是偏差比较大造成的误差，这种情况叫做<strong>欠拟合</strong>。</li>
<li>复杂模型（右边）是方差过大造成的误差，这种情况叫做<strong>过拟合</strong>。</li>
</ul>
<h1 id="怎么判断？"><a href="#怎么判断？" class="headerlink" title="怎么判断？"></a>怎么判断？</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="chapter5-13.png" alt=""></p>
<p>如果模型没有很好的训练训练集，就是偏差过大，也就是欠拟合。</p>
<p>如果模型很好的训练训练集，即再训练集上得到很小的错误，但在测试集上得到大的错误，这意味着模型可能是方差比较大，就是过拟合。</p>
<p>对于欠拟合和过拟合，是用不同的方式来处理的</p>
<h3 id="偏差大-欠拟合"><a href="#偏差大-欠拟合" class="headerlink" title="偏差大-欠拟合"></a>偏差大-欠拟合</h3><p>此时应该重新设计模型。因为之前的函数集里面可能根本没有包含$f^*$。可以：</p>
<ul>
<li>将更多的函数加进去，比如考虑高度重量，或者HP值等等。</li>
<li>考虑更多次幂、更复杂的模型。</li>
<li>如果此时强行再收集更多的data去训练，这是没有什么帮助的，因为设计的函数集本身就不好，再找更多的训练集也不会更好。</li>
</ul>
<h3 id="方差大-过拟合"><a href="#方差大-过拟合" class="headerlink" title="方差大-过拟合"></a>方差大-过拟合</h3><ul>
<li>简单粗暴的方法：更多的数据</li>
</ul>
<p>但是很多时候不一定能做到收集更多的data，可以针对对问题的理解对数据集做调整。</p>
<p>比如识别手写数字的时候，偏转角度的数据集不够，那就将正常的数据集左转15度，右转15度，类似这样的处理。</p>
<ul>
<li>正则化</li>
</ul>
<p>可能伤害偏差，让Model中不包含理想模型，所以要权衡。</p>
<p><img src="chapter5-14.png" alt=""></p>
<h1 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h1><p>现在在偏差和方差之间就需要一个权衡，想选择的模型，可以平衡偏差和方差产生的错误，使得总错误最小。</p>
<p>但是下面这件事最好不要做：</p>
<p><img src="chapter5-15.png" alt=""></p>
<p>用训练集训练不同的模型，然后在测试集上比较错误，模型3的错误比较小，就认为模型3好。但实际上这只是你手上的测试集，真正完整的测试集并没有。比如在已有的测试集上错误是0.5，但有条件收集到更多的测试集后通常得到的错误都是大于0.5的。</p>
<h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p><img src="chapter5-16.png" alt=""></p>
<p>图中public的测试集是已有的，private是没有的，不知道的。</p>
<p><strong>交叉验证</strong>就是将训练集再分为两部分，一部分作为训练集，一部分作为验证集。</p>
<p>用训练集训练模型，然后再验证集上比较，确实出最好的模型之后（比如模型3），再用全部的训练集训练模型3，然后再用public的测试集进行测试，此时一般得到的错误都是大一些的。</p>
<p>不过此时会比较想再回去调一下参数，调整模型，让在public的测试集上更好，但<strong>不太推荐这样</strong>。</p>
<hr>
<p>上述方法可能会担心将训练集拆分的时候分的效果比较差怎么办，可以用下面的方法。</p>
<h2 id="N-折交叉验证"><a href="#N-折交叉验证" class="headerlink" title="N-折交叉验证"></a>N-折交叉验证</h2><p>将训练集分成N份，比如分成3份。</p>
<p><img src="chapter5-17.png" alt=""></p>
<p>比如在三份中训练结果Average错误是模型1最好，再用全部训练集训练模型1。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_04」回归演示</title>
    <url>/2017/03/13/ai-lhyML-04/</url>
    <content><![CDATA[<p>现在假设有10个<code>x_data</code>和<code>y_data</code>，<code>x</code>和<code>y</code>之间的关系是<code>y_data=b+w*x_data</code>。<code>b</code>，<code>w</code>都是参数，是需要学习出来的。现在我们来练习用梯度下降找到<code>b</code>和<code>w</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> mpl</span><br><span class="line"></span><br><span class="line"><span class="comment"># matplotlib没有中文字体，动态解决</span></span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'Simhei'</span>]  <span class="comment"># 显示中文</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_data = [<span class="number">338.</span>, <span class="number">333.</span>, <span class="number">328.</span>, <span class="number">207.</span>, <span class="number">226.</span>, <span class="number">25.</span>, <span class="number">179.</span>, <span class="number">60.</span>, <span class="number">208.</span>, <span class="number">606.</span>]</span><br><span class="line">y_data = [<span class="number">640.</span>, <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>]</span><br><span class="line">x_d = np.asarray(x_data)</span><br><span class="line">y_d = np.asarray(y_data)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">-200</span>, <span class="number">-100</span>, <span class="number">1</span>)</span><br><span class="line">y = np.arange(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">Z = np.zeros((len(x), len(y)))</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># loss</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(y)):</span><br><span class="line">        b = x[i]</span><br><span class="line">        w = y[j]</span><br><span class="line">        Z[j][i] = <span class="number">0</span>  <span class="comment"># meshgrid吐出结果：y为行，x为列</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(x_data)):</span><br><span class="line">            Z[j][i] += (y_data[n] - b - w * x_data[n]) ** <span class="number">2</span></span><br><span class="line">        Z[j][i] /= len(x_data)</span><br></pre></td></tr></table></figure>

<p>先给<code>b</code>和<code>w</code>一个初始值，计算出<code>b</code>和<code>w</code>的偏微分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linear regression</span></span><br><span class="line"><span class="comment">#b = -120</span></span><br><span class="line"><span class="comment">#w = -4</span></span><br><span class="line">b=<span class="number">-2</span></span><br><span class="line">w=<span class="number">0.01</span></span><br><span class="line">lr = <span class="number">0.000005</span></span><br><span class="line">iteration = <span class="number">1400000</span></span><br><span class="line"></span><br><span class="line">b_history = [b]</span><br><span class="line">w_history = [w]</span><br><span class="line">loss_history = []</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    m = float(len(x_d))</span><br><span class="line">    y_hat = w * x_d  +b</span><br><span class="line">    loss = np.dot(y_d - y_hat, y_d - y_hat) / m</span><br><span class="line">    grad_b = <span class="number">-2.0</span> * np.sum(y_d - y_hat) / m</span><br><span class="line">    grad_w = <span class="number">-2.0</span> * np.dot(y_d - y_hat, x_d) / m</span><br><span class="line">    <span class="comment"># update param</span></span><br><span class="line">    b -= lr * grad_b</span><br><span class="line">    w -= lr * grad_w</span><br><span class="line"></span><br><span class="line">    b_history.append(b)</span><br><span class="line">    w_history.append(w)</span><br><span class="line">    loss_history.append(loss)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">10000</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Step %i, w: %0.4f, b: %.4f, Loss: %.4f"</span> % (i, w, b, loss))</span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">"大约需要时间："</span>,end-start)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plot the figure</span></span><br><span class="line">plt.contourf(x, y, Z, <span class="number">50</span>, alpha=<span class="number">0.5</span>, cmap=plt.get_cmap(<span class="string">'jet'</span>))  <span class="comment"># 填充等高线</span></span><br><span class="line">plt.plot([<span class="number">-188.4</span>], [<span class="number">2.67</span>], <span class="string">'x'</span>, ms=<span class="number">12</span>, mew=<span class="number">3</span>, color=<span class="string">"orange"</span>)</span><br><span class="line">plt.plot(b_history, w_history, <span class="string">'o-'</span>, ms=<span class="number">3</span>, lw=<span class="number">1.5</span>, color=<span class="string">'black'</span>)</span><br><span class="line">plt.xlim(<span class="number">-200</span>, <span class="number">-100</span>)</span><br><span class="line">plt.ylim(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">r'$b$'</span>)</span><br><span class="line">plt.ylabel(<span class="string">r'$w$'</span>)</span><br><span class="line">plt.title(<span class="string">"线性回归"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出结果如图</p>
<p><img src="chapter4-1.png" alt=""></p>
<p>横坐标是<code>b</code>，纵坐标是<code>w</code>，标记<code>*</code>为最优解，显然，在图中我们并没有运行得到最优解，最优解十分的遥远。那么我们就调大<code>learning rate</code>，<code>lr = 0.000001</code>（调大10倍），得到结果如下图。</p>
<p><img src="chapter4-2.png" alt=""></p>
<p>我们再调大<code>learning rate</code>，<code>lr = 0.00001</code>（调大10倍），得到结果如下图。</p>
<p><img src="chapter4-3.png" alt=""></p>
<p>结果发现<code>learning rate</code>太大了，结果很不好。</p>
<p>所以我们给<code>b</code>和<code>w</code>特制化两种<code>learning rate</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linear regression</span></span><br><span class="line">b = <span class="number">-120</span></span><br><span class="line">w = <span class="number">-4</span></span><br><span class="line">lr = <span class="number">1</span></span><br><span class="line">iteration = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">b_history = [b]</span><br><span class="line">w_history = [w]</span><br><span class="line"></span><br><span class="line">lr_b=<span class="number">0</span></span><br><span class="line">lr_w=<span class="number">0</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    b_grad=<span class="number">0.0</span></span><br><span class="line">    w_grad=<span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(x_data)):</span><br><span class="line">        b_grad=b_grad<span class="number">-2.0</span>*(y_data[n]-n-w*x_data[n])*<span class="number">1.0</span></span><br><span class="line">        w_grad= w_grad<span class="number">-2.0</span>*(y_data[n]-n-w*x_data[n])*x_data[n]</span><br><span class="line">    </span><br><span class="line">    lr_b=lr_b+b_grad**<span class="number">2</span></span><br><span class="line">    lr_w=lr_w+w_grad**<span class="number">2</span></span><br><span class="line">    <span class="comment"># update param</span></span><br><span class="line">    b -= lr/np.sqrt(lr_b) * b_grad</span><br><span class="line">    w -= lr /np.sqrt(lr_w) * w_grad</span><br><span class="line"></span><br><span class="line">    b_history.append(b)</span><br><span class="line">    w_history.append(w)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># plot the figure</span></span><br><span class="line">plt.contourf(x, y, Z, <span class="number">50</span>, alpha=<span class="number">0.5</span>, cmap=plt.get_cmap(<span class="string">'jet'</span>))  <span class="comment"># 填充等高线</span></span><br><span class="line">plt.plot([<span class="number">-188.4</span>], [<span class="number">2.67</span>], <span class="string">'x'</span>, ms=<span class="number">12</span>, mew=<span class="number">3</span>, color=<span class="string">"orange"</span>)</span><br><span class="line">plt.plot(b_history, w_history, <span class="string">'o-'</span>, ms=<span class="number">3</span>, lw=<span class="number">1.5</span>, color=<span class="string">'black'</span>)</span><br><span class="line">plt.xlim(<span class="number">-200</span>, <span class="number">-100</span>)</span><br><span class="line">plt.ylim(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">r'$b$'</span>)</span><br><span class="line">plt.ylabel(<span class="string">r'$w$'</span>)</span><br><span class="line">plt.title(<span class="string">"线性回归"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="chapter4-4.png" alt=""></p>
<p>有了新的特制化两种<code>learning rate</code>就可以在10w次迭代之内到达最优点了。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_03」回归</title>
    <url>/2017/03/12/ai-lhyML-03/</url>
    <content><![CDATA[<h1 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Regression就是找到一个函数function，通过输入特征 $x$，输出一个数值Scalar。</p>
<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><ul>
<li>股市预测（Stock market forecast）<ul>
<li>输入：过去10年股票的变动、新闻咨询、公司并购咨询等</li>
<li>输出：预测股市明天的平均值</li>
</ul>
</li>
<li>自动驾驶（Self-driving Car）<ul>
<li>输入：无人车上的各个sensor的数据，例如路况、测出的车距等</li>
<li>输出：方向盘的角度</li>
</ul>
</li>
<li>商品推荐（Recommendation）<ul>
<li>输入：商品A的特性，商品B的特性</li>
<li>输出：购买商品B的可能性</li>
</ul>
</li>
<li>Pokemon精灵攻击力预测（Combat Power of a pokemon）：<ul>
<li>输入：进化前的CP值、物种（Bulbasaur）、血量（HP）、重量（Weight）、高度（Height）</li>
<li>输出：进化后的CP值</li>
</ul>
</li>
</ul>
<h1 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h1><ul>
<li>第一步：模型假设，选择模型框架（线性模型）</li>
<li>第二步：模型评估，如何判断众多模型的好坏（损失函数）</li>
<li>第三步：模型优化，如何筛选最优的模型（梯度下降）</li>
</ul>
<blockquote>
<p>评估宝可梦的<strong>CP值（战斗力）</strong>，从而判断是否进化宝可梦.</p>
<p>输入是某只宝可梦：</p>
<ul>
<li>$x$代表宝可梦.</li>
<li>$x_{cp}$代表宝可梦的<strong>CP值</strong>.</li>
<li>$x_s$代表宝可梦的<strong>物种</strong>.</li>
<li>$x_{hp}$代表宝可梦的<strong>生命值</strong>.</li>
<li>$x_w$代表宝可梦的<strong>重量</strong>.</li>
<li>$x_h$代表宝可梦的<strong>高度</strong>.</li>
<li>$y$代表<strong>进化后的CP值</strong>.</li>
</ul>
</blockquote>
<h2 id="第一步-模型"><a href="#第一步-模型" class="headerlink" title="第一步 | 模型"></a>第一步 | 模型</h2><h3 id="一元线性模型-单个特征"><a href="#一元线性模型-单个特征" class="headerlink" title="一元线性模型 | 单个特征"></a>一元线性模型 | 单个特征</h3><p>以一个特征 $x_{cp}$ 为例，线性模型假设 $y = b + w·x_{cp}$ ，所以 $w$ 和 $b$ 可以猜测很多模型：<br>$$<br>f_1: y = 10.0 + 9.0·x_{cp} \<br>f_2: y = 9.8 + 9.2·x_{cp} \<br>f_3: y = - 0.8 - 1.2·x_{cp} \<br>···<br>$$</p>
<p>虽然可以做出很多假设，但在这个例子中，显然 $f_3: y = - 0.8 - 1.2·x_{cp}$ 的假设是不合理的，不能进化后CP值是个负值。</p>
<h3 id="多元线性模型-多个特征"><a href="#多元线性模型-多个特征" class="headerlink" title="多元线性模型 | 多个特征"></a>多元线性模型 | 多个特征</h3><p>在实际应用中，输入特征肯定不止 $x_{cp}$ 这一个。例如，进化前的CP值、物种（Bulbasaur）、血量（HP）、重量（Weight）、高度（Height）等，特征会有很多。</p>
<p><img src="chapter3-1.png" alt=""></p>
<p>例如选择：<br>$$<br>y = b + w \cdot x_{cp}<br>$$</p>
<blockquote>
<p>线性模型：<br>$$<br>y = b + \sum w_i x_i<br>$$<br>其中：</p>
<ul>
<li>$x_i$是输入的不同属性，称为<strong>特征</strong>.</li>
<li>$w_i$是每个特征对应的<strong>权重</strong>.</li>
<li>$b$称为<strong>偏置</strong>.</li>
</ul>
</blockquote>
<h2 id="第二步-模型性能"><a href="#第二步-模型性能" class="headerlink" title="第二步 | 模型性能"></a>第二步 | 模型性能</h2><h3 id="收集和查看训练数据"><a href="#收集和查看训练数据" class="headerlink" title="收集和查看训练数据"></a>收集和查看训练数据</h3><p>接下来要收集<strong>训练数据</strong>才能找到模型的函数.</p>
<p>我们收集的是模型的输入和输出，因为是一个回归的模型，所以<strong>输出是一个数值</strong>.</p>
<p>举例来说（用<strong>上标</strong>表示<strong>完整的对象的编号</strong>，用<strong>下标</strong>表示对象的<strong>成分</strong>）：</p>
<ul>
<li>杰尼龟$x^1$进化到卡咪龟$\hat{y}^1=979$.</li>
<li>伊布$x^2$进化到雷精灵$\hat{y}^2=1420$.</li>
</ul>
<p><img src="chapter3-2.png" alt=""></p>
<p>由此，收集了10只宝可梦的数据：<br>$$<br>(x^1,\hat{y}^1), (x^2,\hat{y}^2), \dots ,(x^{10},\hat{y}^{10})<br>$$<br>可以绘制出来一张$x_{cp}-\hat{y}$的散点图。</p>
<p><img src="chapter3-3.png" alt=""></p>
<h3 id="如何判断众多模型的好坏"><a href="#如何判断众多模型的好坏" class="headerlink" title="如何判断众多模型的好坏"></a>如何判断众多模型的好坏</h3><p><img src="chapter3-4.png" alt=""></p>
<blockquote>
<p>接下来要判断不同函数的好坏，这里需要定义一个新的函数<strong>损失函数$L$</strong>，这是一个函数的函数：</p>
<ul>
<li>输入：一个函数.</li>
<li>输出：这个函数有<strong>多不好</strong>.</li>
</ul>
<p>$$<br>L(f) = L(w,b)<br>$$</p>
<p>因为$f$是由$w, b$决定的，所以我们可以说损失函数是用来衡量一组参数的好坏.</p>
<p>实际上可以选择不同的损失函数的形式，这里就将数据带入到$y = b + w \cdot x_{cp}$中，然后计算差的平方和，即：<br>$$<br>L(f) = L(w,b) = \sum_{n=1}^{10} (\hat{y}^n - (b + w \cdot x_{cp}^n))^2<br>$$</p>
</blockquote>
<p>我们将 $w$, $b$ 在二维坐标图中展示，如图所示：</p>
<p><img src="chapter3-5.png" alt=""></p>
<ul>
<li>图中每一个点代表着一个模型对应的 $w$ 和 $b$</li>
<li>颜色越深代表模型更优</li>
</ul>
<p>可以与后面的图11（等高线）进行对比</p>
<h2 id="第三步-最优模型"><a href="#第三步-最优模型" class="headerlink" title="第三步 | 最优模型"></a>第三步 | 最优模型</h2><blockquote>
<p>根据损失函数来挑选最好的方程<br>$$<br>f^* = \arg \min_f L(f)<br>$$<br>或<br>$$<br>\begin{align}<br>w^* , b^* &amp; = \arg \min_{w,b} L(w, b) \\<br>&amp; = \arg \min_{w,b} \sum_{n=1}^{10} (\hat{y}^n - (b + w \cdot x_{cp}^n))^2<br>\end{align}<br>$$<br>从中选择能够使得损失函数最好的$w,b$参数.</p>
</blockquote>
<p><img src="chapter3-6.png" alt=""></p>
<h3 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h3><p>这里使用<strong>梯度下降法（Gradient Descent）</strong>来处理优化问题.</p>
<p>先假设一个比较简单的损失函数$L(w)$，只包含一个参数$w$.不一定是前面定义的损失函数，可以是任何<strong>可微分</strong>的函数.</p>
<p>现在的问题就是：<br>$$<br>w^* = \arg \min_w L(w)<br>$$<br><img src="chapter3-7.png" alt=""></p>
<p>梯度下降法的做法：</p>
<ol>
<li><strong>随机</strong>选取一个初始的点$w^0$.</li>
<li>计算$\frac{dL}{dw}|_{w=w^0}$，如果算出来斜率是负值，就应该增大$w$；如果计算出来斜率是正值，就应该减小$w$.</li>
<li>参数更新，$w^0 - \eta \frac{dL}{dw}|_{w=w^0} \rightarrow w^1$，其中$\eta$称为学习率.</li>
<li>依次迭代2和3步.</li>
</ol>
<p><img src="chapter3-8.png" alt=""></p>
<p>解释完单个模型参数$w$，引入2个模型参数 $w$ 和 $b$ ， 其实过程是类似的，需要做的是偏微分，过程如图9所示。</p>
<p><img src="chapter3-9.png" alt=""></p>
<blockquote>
<p>推广到两个参数，步骤是一样的：</p>
<ol>
<li><strong>随机</strong>选取一个初始的点$w^0,b^0$.</li>
<li>计算$ \frac{\partial L}{\partial w}|_{w=w^0,b=b^0},\frac{\partial L}{\partial b}|_{w=w^0,b=b^0}$.</li>
<li>参数更新$ w^0 - \eta \frac{\partial L}{\partial w}|_{w=w^0,b=b^0} \rightarrow w^1,b^0 - \eta \frac{\partial L}{\partial b}|_{w=w^0,b=b^0} \rightarrow b^1$.</li>
<li>依次迭代2和3步.</li>
</ol>
<p><strong>注意</strong>：线性回归中，损失函数是<strong>凸函数</strong>，所以局部最优解就是全局最优解.</p>
</blockquote>
<p>整理成一个更简洁的公式：</p>
<p><img src="chapter3-10.png" alt=""></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>求误差之和来评估模型的性能：<br>$$<br>e_{avg} = \sum_{n=1}^{10} e^n<br>$$<br>原来数据的$e_{avg} = 31.9$，又捕捉了10只新的宝可梦，计算$e_{avg} = 35.0$.</p>
<h3 id="梯度下降算法在现实世界中面临的挑战"><a href="#梯度下降算法在现实世界中面临的挑战" class="headerlink" title="梯度下降算法在现实世界中面临的挑战"></a>梯度下降算法在现实世界中面临的挑战</h3><p>我们通过梯度下降gradient descent不断更新损失函数的结果，这个结果会越来越小，那这种方法找到的结果是否都是正确的呢？前面提到的当前最优问题外，还有没有其他存在的问题呢？</p>
<p><img src="chapter3-12.png" alt=""></p>
<p>其实还会有其他的问题：</p>
<ul>
<li>问题1：当前最优（Stuck at local minima）</li>
<li>问题2：等于0（Stuck at saddle point）</li>
<li>问题3：趋近于0（Very slow at the plateau）</li>
</ul>
<p><img src="chapter3-13.png" alt=""></p>
<p>注意：其实在线性模型里面都是一个碗的形状（山谷形状），梯度下降基本上都能找到最优点，但是再其他更复杂的模型里面，就会遇到 问题2 和 问题3 了</p>
<h2 id="选择其他模型-1元N次模型"><a href="#选择其他模型-1元N次模型" class="headerlink" title="选择其他模型 | 1元N次模型"></a>选择其他模型 | 1元N次模型</h2><h3 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h3><p>选择一个更加复杂的模型，带有<strong>二次项</strong>：<br>$$<br>y = b + w_1 \cdot x_{cp} + w_2 \cdot (x_{cp})^2<br>$$<br>甚至带有<strong>三次项</strong>：<br>$$<br>y = b + w_1 \cdot x_{cp} + w_2 \cdot (x_{cp})^2 + w_3 \cdot (x_{cp})^3<br>$$<br><strong>四次项</strong>：<br>$$<br>y = b + w_1 \cdot x_{cp} + w_2 \cdot (x_{cp})^2 + w_3 \cdot (x_{cp})^3 + w_4 \cdot (x_{cp})^4<br>$$<br>出现了<strong>过拟合</strong>.</p>
<p><img src="chapter3-18.png" alt=""></p>
<p><img src="chapter3-19.png" alt=""></p>
<p><img src="chapter3-20.png" alt=""></p>
<h3 id="优化方法1-用四个线性模型表示"><a href="#优化方法1-用四个线性模型表示" class="headerlink" title="优化方法1 | 用四个线性模型表示"></a>优化方法1 | 用四个线性模型表示</h3><p>通过对 Pokemons种类 判断，将<strong>4个线性模型</strong>合并到一个线性模型中</p>
<p><img src="chapter3-24.png" alt=""></p>
<p><img src="chapter3-25.png" alt=""></p>
<p><img src="chapter3-26.png" alt=""></p>
<h3 id="优化方法2-使用更多参数"><a href="#优化方法2-使用更多参数" class="headerlink" title="优化方法2 | 使用更多参数"></a>优化方法2 | 使用更多参数</h3><p>在最开始我们有很多特征，图形化分析特征，将血量（HP）、重量（Weight）、高度（Height）也加入到模型中</p>
<p><img src="chapter3-27.png" alt=""></p>
<p><img src="chapter3-28.png" alt=""></p>
<p>更多特征，更多input，数据量没有明显增加，仍旧导致overfitting</p>
<h3 id="优化方法3-加入正则化"><a href="#优化方法3-加入正则化" class="headerlink" title="优化方法3 | 加入正则化"></a>优化方法3 | 加入正则化</h3><p><img src="chapter3-29.png" alt=""></p>
<p><img src="chapter3-30.png" alt=""></p>
<blockquote>
<p>前面的损失函数只考虑了预测值和实际值之间的<strong>误差</strong>，正则化就是给损失函数加上额外的项.<br>$$<br>y = b + \sum w_i x_i<br>$$</p>
<p>$$<br>L = \sum_{n} (\hat{y}^n - (b + w \cdot x_{cp}^n))^2 + \lambda \sum (w_i)^2<br>$$</p>
</blockquote>
<ul>
<li>函数中$w_i$参数越小，函数越<strong>平滑</strong>的，函数对于输入变化不敏感，输入的变化对输出的变化影响很小，降低噪声干扰.</li>
<li>$\lambda$的数值越大，我们对$w_i$<strong>参数本身</strong>越关注，而减少了对误差的关注.我们可以手动调整$\lambda$的数值.</li>
<li>偏置$b$并不会影响函数的平滑程度，而只是让函数上下移动，所以正则化不用考虑偏置项.</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><strong>Pokemon</strong>：原始的CP值极大程度的决定了进化后的CP值，但可能还有其他的一些因素。</li>
<li><strong>Gradient descent</strong>：梯度下降的做法；后面会讲到它的理论依据和要点。</li>
<li><strong>Overfitting和Regularization</strong>：过拟合和正则化，主要介绍了表象；后面会讲到更多这方面的理论。</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_02」为什么要学习机器学习</title>
    <url>/2017/03/12/ai-lhyML-02/</url>
    <content><![CDATA[<p><img src="chapter2-1.png" alt=""></p>
<p>各位同学，大家好，今天我要来讲，为什么我们需要学习机器学习。听说AI要来取代人类的工作了，大家都很担心。</p>
<blockquote>
<p>为什么我们需要学习机器学习？</p>
<p>AI即将取代部分的工作？</p>
<p>新工作：AI训练师</p>
</blockquote>
<p>但大家不用担心会出现一个新的工作，叫做AI训练师，机器不是自己会学吗？为什么需要AI训练师。</p>
<p><img src="chapter2-3.png" alt=""></p>
<p>这个问题就好像是问说，为什么需要宝可梦训练师？我记得宝可梦训练师都只在旁边嘴炮，都不自己战斗。但是我们知道，宝可梦训练师，其实很重要，例如说战斗时要选择属性适合的宝可梦。不然就会像这样（动画场景：你这个白痴，难道你不知道飞行系的遇到岩石系的神奇宝贝是没作用的吗？）。</p>
<blockquote>
<p><strong>AI训练师</strong></p>
<ul>
<li><p>AI训练师要挑选合适的model、loss function</p>
<ul>
<li>不同model、loss function适合解决不同的问题</li>
</ul>
</li>
<li><p>不一定能找出best function</p>
<ul>
<li>E.g. Deep Learning</li>
<li>需要有经验的AI训练师</li>
</ul>
</li>
</ul>
</blockquote>
<p>同样地AI训练师需要为机器挑选合适的model和loss function。不同的model和loss function适合解决不同的问题。</p>
<blockquote>
<p><strong>宝可梦训练师</strong></p>
<ul>
<li>宝可梦训练师要挑选适合的宝可梦来战斗<ul>
<li>宝可梦有不同的属性</li>
</ul>
</li>
<li>召唤出来的宝可梦不一定听话<ul>
<li>E.g. 小智的喷火龙</li>
<li>需要有经验的宝可梦训练师</li>
</ul>
</li>
</ul>
</blockquote>
<p>另外，我们知道，召唤出来的宝可梦，不一定会听话。例如说（动画场景：真的没有问题吗？小健，你放心，我相信喷火龙一定办得到）。也有些模型的最佳化比较困难，例如深度学习，可能会需要有经验的AI训练师来处理。</p>
<p><img src="chapter2-6.png" alt=""></p>
<p>因此，我们知道要训练出厉害的AI，AI训练师功不可没，所以让我们一起朝AI训练师之路迈进。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_01」机器学习介绍</title>
    <url>/2017/03/12/ai-lhyML-01/</url>
    <content><![CDATA[<h1 id="机器学习介绍"><a href="#机器学习介绍" class="headerlink" title="机器学习介绍"></a>机器学习介绍</h1><p><img src="chapter1-1.png" alt=""></p>
<p>这门课，我们预期可以学到什么呢？我想多数同学的心理预期就是你可以学到一个很潮的人工智慧。我们知道，从今年开始，人工智慧这个词突然变得非常非常非常的热门，讲大家、政府通都在讲人工智慧这个词。</p>
<p>但人工智慧是什么呢？人工智慧其实一点都不是新的词汇，人工智慧（AI）、Artificial Intelligence这个词汇，在1950年代就有了。那这个词意味着什么呢？这个词意味着一个人类长远以来的目标，希望机器可以跟人一样的聪明。在科幻小说里面，我们看要很多这样的幻想和期待。但很长段时间里面，人们并不知道怎么做到人工智慧这件事情，直到后来，大概1980年代以后，有了机器学习的方法。那么机器学习顾名思义，从名字就可以被猜出，就是让机器具有学习的能力。所以机器学习跟人工智慧之间什么关系呢？</p>
<p><strong>人工智慧是我们想要达成的目标，而机器学习是想要达成目标的手段，希望机器通过学习方式，他跟人一样聪明。而深度学习和机器学习有什么关系呢？深度学习就是机器学习的其中一种方法。</strong></p>
<p>在有深度学习、机器学习之前，人们用什么样的方式来做到人工智慧这件事呢？我记得高中生物学告诉我们说：生物的行为取决于两件事，一个是后天学习的结果，不是后天学习的结果就是先天的本能。对于机器来说也是一样，他怎么样表现的很有智慧，要么就是通过后天学习的手段表现的很有智慧，要么就是它的先天的本能。机器为什么会有先天的本能，那可能就是他的创造者，其实都是人类，帮它事先设立好的。</p>
<hr>
<p><img src="chapter1-2.png" alt=""></p>
<p>现在先来看一下生物的本能，讲一个跟机器学习一点都没有关系的内容：生物的本能。如图这个是河狸，那河狸的特色呢就是它会筑水坝把水挡起来。但是河狸怎么知道要筑水坝呢？河狸筑水坝能力是天生的。也就是说，假设河狸他在实验室出生，它没有父母叫他怎么筑水坝。但是他一生下来，它心里就有个冲动，就是它想要筑水坝。那如果我们要程序语言来描述他的话，他那的程序语言就是这样的：</p>
<p><img src="chapter1-3.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">If 它听到流水声</span><br><span class="line"></span><br><span class="line">Then 它就筑水坝直到他听不到流水声</span><br></pre></td></tr></table></figure>

<p><img src="chapter1-4.png" alt=""></p>
<p>所以，生物学家就可以欺负河狸，他用一个扬声器来播放流水声，如果他把扬声器流放在水泥墙里面，然后河狸就会在水泥墙上面的放很多的树枝，在水泥墙上面筑堤，想把扬声器的声音盖住。如果你把扬声器放在地上，河狸就会用树枝把他盖住直到你听不见扬声器的声音为止。这就是生物的本能，那机器的本能跟生物的本能其实也很像。 </p>
<hr>
<p><img src="chapter1-5.png" alt=""></p>
<p>假设有一天你想要做一个chat-bot，如果你不是用机器学习的方式，而是给他天生的本能的话，那像是什么样子呢？你可能就会在这个chat-bot里面，在这个聊天机器人里面的设定一些规则，这些规则我们通常称hand-crafted rules，叫做人设定的规则。那假设你今天要设计一个机器人，他可以帮你打开或关掉音乐，那你的做法可能是这样：设立一条规则，就是写程序。如果输入的句子里面看到“turn off”这个词汇，那chat-bot要做的事情就是把音乐关掉。这个时候，你之后对chat-bot说，Please turn off the music  或can you turn off the music, Smart? 它就会帮你把音乐关掉。看起来好像很聪明。别人就会觉得果然这就是人工智慧。但是如果你今天想要欺负chat-bot的话，你就可以说please don‘t turn off the music，但是他还是会把音乐关掉。这是个真实的例子，你可以看看你身边有没有这种类似的chat-bot，然后你去真的对他说这种故意欺负它的话，它其实是会答错的。这是真实的例子，但是不告诉他是哪家公司产品，这家公司也是号称他们做很多AI的东西的。</p>
<p><img src="chapter1-6.png" alt=""></p>
<p>使用hand-crafted rules有什么样的坏处呢，它的坏处就是：使用hand-crafted rules你没办法考虑到所有的可能性，它非常的僵化，而用hand-crafted rules创造出来的machine，它永远没有办法超过它的创造者人类。人类想不到东西，就没办法写规则，没有写规则，机器就不知道要怎么办。所以如果一个机器，它只能够按照人类所设定好的hand-crafted rules，它整个行为都是被规定好的，没有办法freestyle。如果是这样的话，它就没有办法超越创造他的人类。</p>
<p>你可能会说，但是你好像看到很多chat-bot看起来非常的聪明。如果你是有一个是一个非常大的企业，他给以派给成千上万的工程师，用血汗的方式来建出数以万计的规则，然后让他的机器看起来好像很聪明。但是对于中小企业来说，这样建规则的方式反而是不利的。所以我认为机器学习发展，对比较小规模企业反而是更有利的。因为接下来，不需要非常大量的人来帮你想各式各样的规则，只要手上有data，你可以让机器来帮你做这件事情。当然怎么收集data又是另外一个问题，这不是我们今天要讨论的主题。</p>
<p><img src="chapter1-7.png" alt=""></p>
<p>AI这个词现在非常非常非常非常的热门，所以会有各式各样、奇奇怪怪的东西，我觉得现在非常经常碰到的一个问题，也许可用以下这个漫画来说明，这是四格漫画，而这个漫画并不是随随便便的一个四格漫画，这个漫画是facebook上的漫画。</p>
<p>这个漫画想要说的是：现在你一定常常新闻或者是商场上看到这个讯息，有一个seller说看看我们最新的人工智慧机器人，它就是非常的人工智慧。这个系统搭配一个能言善道seller，加上一个非常非常潮的前端和外壳，里面是什么没有人知道。</p>
<p>外面的观众就问说：他是用什么neural方法做的，反正就是最潮的AI的技术。但是你把他剖来看一看，里面通通都是if掉出来。</p>
<hr>
<p>现在政府、企业都说想要推广的AI，可是他们想要推广AI其实是这种AI。那这个其实都不是我们现在应该做的事，如果你要推动，如果你要推广的是这种hand-crafted AI的话，你怎么五十年前不推广，一直到今天才出来做呢？今天我们要走的不是这个路线，如果是这个路线是要被diss的，</p>
<p><img src="chapter1-8.png" alt=""></p>
<p>我们要做的其实是让机器他有自己学习的能力，也就我们要做的应该machine learning的方向。讲的比较拟人化一点，所谓machine learning的方向，就是你就写段程序，然后让机器人变得了很聪明，他就能够有学习的能力。接下来，你就像教一个婴儿、教一个小孩一样的教他，你并不是写程序让他做到这件事，你是写程序让它具有学习的能力。然后接下来，你就可以用像教小孩的方式告诉它。假设你要叫他学会做语音辨识，你就告诉它这段声音是“Hi”，这段声音就是“How are you”，这段声音是“Good bye”。希望接下来它就学会了，你给它一个新的声音，它就可以帮你产生语音辨识的结果。</p>
<p><img src="chapter1-9.png" alt=""></p>
<p>如果你希望他学会怎么做影像辨识，你可能不太需要改太多的程序。因为他本身就有这种学习的能力，你只是需要交换下告诉它：看到这张图片，你要说这是猴子；看到这张图片，然后说是猫；看到这张图片，可以说是狗。它具有影像辨识的能力，接下来看到它之前没有看过的猫，希望它可以认识。</p>
<p><img src="chapter1-10.png" alt=""></p>
<p>如果讲的更务实一点的话，machine learning所做的事情，你可以想成就是在寻找一个function，要让机器具有一个能力，这种能力是根据你提供给他的资料，它去寻找出我们要寻找的function。还有很多关键问题都可以想成是我们就是需要一个function。</p>
<hr>
<p><img src="chapter1-11.png" alt=""></p>
<p>在语音辨识这个问题里面，我们要找一个function，它的输入是声音讯号，他的输出是语音辨识的文字。这个function非常非常的复杂，有人会想说我来用一些写规则的方式，读很多语言学文献，然后写一堆规则，然后做语音辨识。这件事情，60年代就有人做，但到现在都还没有做出来。语音辨识太过复杂，这个function太过的复杂，不是人类所可以写出来，这是可以想象的。所以我们需要凭借的机器的力量，帮我们把这个function找出来。</p>
<p>假设你要做影像辨识，那就是找一个function，输入一张图片，然后输出图片里面有什么样的东西。或者是大家都一直在说的Alpha GO，如果你要做一个可以下围棋machine时，其实你需要的也就是找一个function。这个function的输入是围棋上十九* 十九的棋盘。告诉机器在十九* 十九的棋盘上，哪些位置有黑子，哪些位置有白子。然后机器就会告诉你，接下来下一步应该落子在哪。或者是你要做一个聊天机器人，那你需要的是一个function，这个function的输入就是使用者的input，它的输出就是机器的回应。</p>
<p><img src="chapter1-12.png" alt=""></p>
<hr>
<p>以下我先很简短的跟大家说明怎么样找出这个function，找出function的framework是什么呢？我们以影像辨识为例，我们找个function输入一张图片，它告诉我们这个图片里面有什么样的东西。</p>
<p><img src="chapter1-13.png" alt=""></p>
<p>在做这件事时，你的起手事是你要先准备一个function set(集合)，这个function里面有成千上万的function。举例来说，这个function在里面,有一个$f_1$，你给它看一只猫，它就告诉你输出猫，看一只狗就输出狗。有一个function $f_2$它很怪，你给它看猫，它说是猴子；你给他看狗，它说是蛇。你要准备一个function set，这个function set里面有成千上万的function。这件事情讲起来可能有点抽象，你可能会怀疑说怎么会有成千上万的function，我怎么把成千上万的function收集起来，这个内容我们之后会再讲。</p>
<p><img src="chapter1-14.png" alt=""></p>
<p>总之，我们先假设你手上有一个function set，这个function set就叫做model（模型）。</p>
<p><img src="chapter1-15.png" alt=""></p>
<p>有了这个function set，接下来机器要做的事情是：它有一些训练的资料，这些训练资料告诉机器说一个好的function，它的输入输出应该长什么样子，有什么样关系。你告诉机器说呢，现在在这个影像辨识的问题里面，如果看到这个猴子，看到这个猴子图也要输出猴子，看到这个猫的图也要输出猫，看到这个狗的图，就要输出狗，这样才是对的。只有这些训练资料，你拿出一个function，机器就可以判断说，这个function是好的还是不好的。</p>
<p><img src="chapter1-16.png" alt=""></p>
<p>机器可以根据训练资料判断一个function是好的，还是不好的。举例来说：在这个例子里面显然$f_1$，他比较符合training data的叙述，比较符合我们的知识。所以$f_1$看起来是比较好的。$f_2$看起来是一个荒谬的function。我们今天讲的这个task叫做supervised learning。</p>
<p><img src="chapter1-17.png" alt=""></p>
<p>如果你告诉机器input和output这就叫做supervised learning，之后我们也会讲到其他不同的学习场景。现在机器有办法决定一个function的好坏。但光能够决定一个function的好坏是不够的，因为在你的function set里面，他有成千上万的function，它有会无穷无尽的function，所以我们需要一个有效率的演算法，有效率的演算法可以从function的set里面挑出最好的function。一个一个衡量function的好坏太花时间，实际上做不到。所以我们需要有一个好的演算法，从function set里面挑出一个最好的的function，这个最好的function将它记为$ f^* $。</p>
<p><img src="chapter1-18.png" alt=""></p>
<p>找到$ f^* $之后，我们希望用它应用到一些场景中，比如：影像辨识，输入一张在机器没有看过的猫，然后希望输出也是猫。你可能会说：机器在学习时没有看到这只猫，那咋样知道在测试时找到的最好function $f^ *$可以正确辨识这只猫呢？这就是machine learning里面非常重要的问题：机器有举一反三的能力，这个内容后面再讲。</p>
<p><img src="chapter1-19.png" alt=""></p>
<p>左边这个部分叫training，就是学习的过程；右边这个部分叫做testing，学好以后你就可以拿它做应用。所以在整个machine learning framework整个过程分成了三个步骤。第一个步骤就是找一个function，第二个步骤让machine可以衡量一个function是好还是不好，第三个步骤是让machine有一个自动的方法，有一个好演算法可以挑出最好的function。</p>
<p><img src="chapter1-20.png" alt=""></p>
<p>机器学习其实只有三个步骤，这三个步骤简化了整个process。可以类比为：把大象放进冰箱。我们把大象塞进冰箱，其实也是三个步骤：把门打开；象塞进去；后把门关起来，然后就结束了。所以说，机器学习三个步骤，就好像是说把大象放进冰箱，也只需要三个步骤。</p>
<h1 id="机器学习相关的技术"><a href="#机器学习相关的技术" class="headerlink" title="机器学习相关的技术"></a>机器学习相关的技术</h1><p><img src="chapter1-21.png" alt=""></p>
<p>如图为这学期的Learning Map，看起来是有点复杂的，我们一块一块来解释，接下里我们将从图的左上角来进行学习。</p>
<h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p><img src="chapter1-22.png" alt=""></p>
<p>Regression是一种machine learning的task，当我们说：我们要做regression时的意思是，machine找到的function，它的输出是一个scalar，这个叫做regression。举例来说，在作业一里面，我们会要你做PM2.5的预测（比如说预测明天上午的PM2.5） ，也就是说你要找一个function，这个function的输出是未来某一个时间PM2.5的一个数值，这个是一个regression的问题。</p>
<p>机器要判断function明天上午的PM2.5输出，你要提供给它一些资讯，它才能够猜出明天上午的PM2.5。你给他资讯可能是今天上的PM2.5、昨天上午的PM2.5等等。这是一个function，它吃我们给它过去PM2.5的资料，它输出的是预测未来的PM2.5。</p>
<p><img src="chapter1-23.png" alt=""></p>
<p>若你要训练这种machine，如同我们在Framework中讲的，你要准备一些训练资料，什么样的训练资料？你就告诉它是今天我们根据过去从政府的open data上搜集下来的资料。九月一号上午的PM2.5是63，九月二号上午的PM2.5是65，九月三号上午的PM2.5是100。所以一个好的function输入九月一号、九月二号的PM2.5，它应该输出九月三号的PM2.5；若给function九月十二号的PM2.5、九月十三号的PM2.5，它应该输出九月十四号的PM2.5。若收集更多的data，那你就可以做一个气象预报的系统。</p>
<p><img src="chapter1-24.png" alt=""></p>
<p>接下来讲的是Classification（分类）的问题。Regression和Classification的差别就是我们要机器输出的东西的类型是不一样。在Regression中机器输出的是一个数值，在Classification里面机器输出的是类别。假设Classification问题分成两种，一种叫做二分类输出的是是或否（Yes or No）；另一类叫做多分类（Multi-class），在Multi-class中是让机器做一个选择题，等于是给他数个选项，每个选项都是一个类别，让他从数个类别里选择正确的类别。</p>
<p><img src="chapter1-25.png" alt=""></p>
<p>举例来说，二分类可以鉴别垃圾邮件，将其放到垃圾箱。那怎么做到这件事呢？其实就是需要一个function，它的输入是一个邮件，输出为邮件是否为垃圾邮件。</p>
<p><img src="chapter1-26.png" alt=""></p>
<p>你要训练这样的function很简单，给他一大堆的Data并告诉它，现在输入这封邮件，你应该说是垃圾邮件，输入这封邮件，应该说它不是垃圾邮件。你给他够多的这种资料去学，它就可以自动找出一个可以侦测垃圾邮件的function。</p>
<p><img src="chapter1-27.png" alt=""></p>
<p>多分类的举一个文章分类的例子，现在网络上有非常非非常多的新闻，也许没有人会把所有的新闻看完，但希望机器自动帮一把新闻做分类。怎么做呢？你需要的是一个function，它的输入是一则新闻，输出是新闻属于哪个类别，你要做的事情就是解这个选择题。</p>
<p>若要训练这种机器就要准备很多训练资料（Training Data），然后给它新的文章，新闻它能给你正确的结果。</p>
<p><img src="chapter1-28.png" alt=""></p>
<p>刚才讲的都是让machine去解的任务，接下来要讲的是在解任务的过程中第一步就是要选择function set，选不同的function set就是选不同的model。Model有很多种，最简单的就是线性模型，但我们会花很多时间在非线性的模型上。在非线性的模型中最耳熟能详的就是Deep learning。</p>
<p><img src="chapter1-29.png" alt=""></p>
<p>在做Deep learning时，它的function是特别复杂的，所以它可以做特别复杂的事情。比如它可以做影像辨识，这个复杂的function可以描述pixel和class之间的关系。</p>
<p><img src="chapter1-30.png" alt=""></p>
<p>用Deep learning的技术也可以让机器下围棋，下围棋这个task 其实就是一个分类的问题。对分类问题我们需要一个很复杂的function，输入是一个棋盘的格子，输出就是下一步应该落子的位置。我们知道一个棋盘上有十九乘十九的位置可以落子，所以今天下围棋这件事情，你就可以把它想成是一个十九乘十九个类别的分类问题，或者是你可以把它想成是一个有十九乘十九个选项的选择题。</p>
<p><img src="chapter1-31.png" alt=""></p>
<p>你要怎么训练机器让他学会下围棋呢？你要搜集训练资料，告诉机器现在这个function输入输出分别应该是什么。就看到某样的盘式，我们应该输出什么样结果。</p>
<p>怎么收集资料呢？你可以从人类过去下的棋库里面搜集。举例来说，你收集了进藤光和社新春下的那一盘棋的棋谱。社新春出手先下五之5，进藤光次手下天元，社新春第三手下五之5。</p>
<p><img src="chapter1-32.png" alt=""></p>
<p>所以若你有了这样的棋谱之后，可以告诉machine如果现在有人落子下5之五，下一步就落子在天元；若五之五和天元都有落子，那就要落子在另外一个五之5上。然后你给它足够多的棋谱，他就学会下围棋了。</p>
<p><img src="chapter1-33.png" alt="">))</p>
<p>除了deep learning 以外还有很多machine learning的model也是非线性的模型，这学期会请吴佩云老师来帮我们讲SVM。</p>
<h2 id="半监督学习"><a href="#半监督学习" class="headerlink" title="半监督学习"></a>半监督学习</h2><p><img src="chapter1-34.png" alt=""></p>
<p>刚才我们讲的都是supervised learning（监督学习），监督学习的问题是我们需要大量的training data。training data告诉我们要找的function的input和output之间的关系。如果我们在监督学习下进行学习，我们需要告诉机器function的input和output是什么。这个output往往没有办法用很自然的方式取得，需要人工的力量把它标注出来，这些function的output叫做label。</p>
<p>那有没有办法减少label需要的量呢？就是半监督学习。</p>
<p><img src="chapter1-35.png" alt=""></p>
<p>假设你先想让机器鉴别猫狗的不同。你想做一个分类器让它告诉你，图片上是猫还是狗。你有少量的猫和狗的labeled data，但是同时你又有大量的Unlabeled data，但是你没有力气去告诉机器说哪些是猫哪些是狗。在半监督学习的技术中，这些没有label的data，他可能也是对学习有帮助。这个我们之后会讲为什么这些没有label的data对学习会有帮助。</p>
<h2 id="迁移学习"><a href="#迁移学习" class="headerlink" title="迁移学习"></a>迁移学习</h2><p><img src="chapter1-36.png" alt=""></p>
<p>另外一个减少data用量的方向是迁移学习。</p>
<p><img src="chapter1-37.png" alt=""></p>
<p>迁移学习的意思是：假设我们要做猫和狗的分类问题，我们也一样，只有少量的有label的data。但是我们现在有大量的data，这些大量的data中可能有label也可能没有label。但是他跟我们现在要考虑的问题是没有什么特别的关系的，我们要分辨的是猫和狗的不同，但是这边有一大堆其他动物的图片还是动画图片（凉宫春日，御坂美琴）你有这一大堆不相干的图片，它到底可以带来什么帮助。这个就是迁移学习要讲的问题。</p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p><img src="chapter1-38.png" alt=""></p>
<p>更加进阶的就是无监督学习，我们希望机器可以学到无师自通。</p>
<p><img src="chapter1-39.png" alt=""></p>
<p>如果在完全没有任何label的情况下，到底机器可以学到什么样的事情。举例来说，如果我们给机器看大量的文章（在去网络上收集站文章很容易，网络上随便爬就可以）让机器看过大量的文章以后，它到底可以学到什么事情。</p>
<p><img src="chapter1-40.png" alt=""></p>
<p>它能不能够学会每一个词汇的意思，要让机器学会每一个词汇的意思，你可以想成是我们找一个function，然后你把一个词汇丢进去。比如说你把“apple”丢进这个function里面，机器要输出告诉你说这个词会是什么意思。也许他用一个向量来表示这个词汇的各种不同的特性。但现在讲是无监督学习的问题，你现在只有一大堆的文章，也就是说你只有词汇，你只有function的输入，没有任何的输出。那你到底要怎么解决这个问题。</p>
<p><img src="chapter1-41.png" alt=""></p>
<p>我们举另外一个无监督学习的例子：假设我们今天带机器去动物园让它看一大堆的动物，它能不能够在看了一大堆动物以后，它就学会自己创造一些动物。那这个都是真实例子。仔细看了大量的动物以后，它就可以自己的画一些狗出来。有眼睛长在身上的狗、还有乳牛狗等等。</p>
<p><img src="chapter1-42.png" alt=""></p>
<p>这个Task也是一个无监督学习的问题，这个function的输入不知道是什么，可能是某一个code代表要输出图片的特性，输出是一张图片。你给机器看到的只有非常大量的图片，只有function的input，没有output。机器要咋样生成新的图片，这是我们后面要解决的问题。</p>
<h2 id="监督学习中的结构化学习"><a href="#监督学习中的结构化学习" class="headerlink" title="监督学习中的结构化学习"></a>监督学习中的结构化学习</h2><p><img src="chapter1-43.png" alt=""></p>
<p>在machine要解的任务上我们讲了Regression、classification，还有一类的问题是structured learning。</p>
<p><img src="chapter1-44.png" alt=""></p>
<p>structured learning 中让机器输出的是要有结构性的，举例来说：在语音辨识里面，机器输入是声音讯号，输出是一个句子。句子是要很多词汇拼凑完成。它是一个有结构性的object。或者是说在机器翻译里面你说一句话，你输入中文希望机器翻成英文，它的输出也是有结构性的。或者你今天要做的是人脸辨识，来给机器看张图片，它会知道说最左边是长门，中间是凉宫春日，右边是宝玖瑠。然后机器要把这些东西标出来，这也是一个structure learning问题。 </p>
<p><img src="chapter1-45.png" alt=""></p>
<p>其实多数人可能都听过regression，也听过classification，你可能不见得听过structure learning。很多教科书都直接说，machine learning是两大类的问题，regression，和classification。machine learning只有regression和classification两类问题，就好像告诉你：我们所熟知的世界只有五大洲，但是这只是真实世界的一小部分，真正的世界是如图所示。</p>
<p>真正世界还应该包括structure learning，这里面还有很多问题是没有探究的。</p>
<h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p><img src="chapter1-46.png" alt=""></p>
<p>最后一部分就是reinforcement learning的问题。</p>
<p><img src="chapter1-47.png" alt=""></p>
<p>reinforcement learning其实是一个已经发展了很久的技术，但近期受到大家的关注是因为data mining将reinforcement learning技术用来玩一些小游戏。另外一个就是Alpha Go。</p>
<p><img src="chapter1-48.png" alt=""></p>
<p>我们若将强化学习和监督学习进行比较时，在监督学习中我们会告诉机器正确答案是什么。若现在我们要用监督学习的方法来训练一个聊天机器人，你的训练方式会是：你就告诉机器，现在使用者说了hello，你就说hi，现在使用者说了byebye ，你就说good bye。所以机器有一个人当他家教在他旁边手把手的教他每件事情，这就是监督学习。</p>
<p>reinforcement learning是什么呢？在reinforcement learning里面，我们没有告诉机器正确的答案是什么，机器所拥有的只有一个分数，就是他做的好还是不好。若我们现在要用reinforcement learning方法来训练一个聊天机器人的话，他训练的方法会是这样：你就把机器发到线下，让他的和面进来的客人对话，然后想了半天以后呢，最后仍旧勃然大怒把电话挂掉了。那机器就学到一件事情就是刚才做错了。但是他不知道哪边错了，它就要回去自己想道理，是一开始就不应该打招呼吗？还是中间不应该在骂脏话了之类。它不知道，也没有人告诉它哪里做的不好，它要回去反省检讨哪一步做的不好。机器要在reinforcement learning的情况下学习，机器是非常intelligence的。</p>
<p>reinforcement learning也是比较符合我们人类真正的学习的情景，这是你在学校里面的学习老师会告诉你答案，但在真实社会中没人回告诉你正确答案。你只知道你做得好还是做得不好，如果机器可以做到reinforcement learning，那确实是比较intelligence。</p>
<p><img src="chapter1-49.png" alt=""></p>
<p>若我们用Alpha Go当做例子时，supervised learning就是告诉机器：看到这个盘式你就下“5-5”，看到这个盘式你就下“3-3”</p>
<p>reinforcement learning的意思是：机器跟对手互下，机器会不断的下棋，最后赢了，机器就会知道下的不错，但是究竟是哪里可以使它赢，它其实是不知道的。我们知道Alpha Go其实是用监督学习加上reinforcement learning去学习的。先用棋谱做监督学习，然后在做reinforcement learning，但是reinforcement learning需要一个对手，如果使用人当对手就会很让费时间，所以机器的对手是另外一个机器。</p>
<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p><img src="chapter1-50.png" alt=""></p>
<p>大家注意一下这个不同的方块，我是用不同的颜色来表示。</p>
<p>同样的颜色不同的方块是同一个类型的，这边的蓝色的方块，指的是学习的情景，通常学习的情景是你没有办法控制的。比如，因为我们没有data做监督学习，所以我们才做reinforcement learning。现在因为Alpha Go比较火，所以Alpha Go中用到的reinforcement learning会被认为比较潮。所以说有学生去面试，说明自己是做监督学习的，就会被质疑为什么不做reinforcement learning。那这个时候你就应该和他说，如果我今天可以监督学习，其实就不应该做reinforcement learning。reinforcement learning就是我们没有办法做监督学习的时候，我们才做reinforcement learning。</p>
<p>红色的是指你的task，你要解的问题，你要解的这个问题随着你用的方程的不同，有regression、有classification、有structured。所以在不同的情境下，都有可能要解这个task。</p>
<p>最后，在这些不同task里面有不同的model，用绿色的方块表示。</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「线性代数_01」矩阵及其应用</title>
    <url>/2017/02/28/linearAlgebra-01/</url>
    <content><![CDATA[<h1 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h1><h2 id="矩阵的概念-1"><a href="#矩阵的概念-1" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h2><blockquote>
<p><strong>定义：</strong></p>
<p>由$ m \times n $个数$ a_{ij} ( i=1,2,…,m;j=1,2,…,n ) $排成一个$ m $行$ n $列的矩形数表<br>$$<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1} &amp; a_{m2} &amp; \dots &amp; a_{mn}<br>\end{pmatrix}<br>$$</p>
<p>或</p>
<p>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1} &amp; a_{m2} &amp; \dots &amp; a_{mn}<br>\end{bmatrix}<br>$$</p>
<p>称为$ m \times n $矩阵或$ m $行$ n $列矩阵，简称<strong>矩阵</strong>.横排称为矩阵的<strong>行</strong>，纵排称为矩阵的<strong>列</strong>，$ a_{ij} ( i=1,2,…,m;j=1,2,…,n ) $称为矩阵的第$ i $行第$ j $列<strong>元</strong>或$ (i,j) $<strong>元</strong>.$ m \times n $矩阵通常用大写字母如$ \pmb{A},\pmb{B},… $表示，有时也记作$ \pmb{A} = ( a_{ij} )_{m \times n} $.</p>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>实矩阵</strong>：元都是实数的矩阵.</li>
<li><strong>复矩阵</strong>：元都是复数的矩阵.</li>
<li><strong>零矩阵</strong>：元都是$ 0 $的矩阵，记为$ \pmb{O} $.</li>
<li><strong>列矩阵</strong>：只有一列的矩阵，也称为列向量.</li>
</ul>
<p>$$<br>\pmb{A} =<br>\begin{pmatrix}<br>a_1 \\<br>a_2 \\<br>\vdots \\<br>a_m<br>\end{pmatrix}<br>$$</p>
<ul>
<li><strong>行矩阵</strong>：只有一行的矩阵，也称为行向量.</li>
</ul>
<p>$$<br>\pmb{B} =<br>\begin{pmatrix}<br>b_1 &amp; b_2 &amp; \dots &amp;    b_n<br>\end{pmatrix}<br>$$</p>
<ul>
<li><p>行向量和列向量也可以用小写字母$ \pmb{a}, \pmb{b},…; \pmb{\alpha} , \pmb{\beta} , … $表示.</p>
</li>
<li><p>若$ m=n $，即矩阵的行数与列数相同时，称矩阵为<strong>$ n $阶矩阵</strong>或<strong>$ n $阶方阵</strong>.在$ n $阶矩阵<strong>$ A $</strong>中，从左上角到右下角的对角线称为$ \pmb{A} $的<strong>主对角线</strong>，主对角线上的元$ a_{ii} $称为$ n $阶矩阵$ \pmb{A} $的主对角线元；从右上角到左下角的对角线称为$ \pmb{A} $的<strong>次对角线</strong>.</p>
</li>
</ul>
</blockquote>
<h2 id="几种特殊矩阵"><a href="#几种特殊矩阵" class="headerlink" title="几种特殊矩阵"></a>几种特殊矩阵</h2><ul>
<li><p><strong>上三角（形）矩阵</strong>：主对角线以下的元全为$ 0 $的$ n $阶方阵.<br>$$<br>\pmb{A} =<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>0 &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>0 &amp; 0 &amp; \dots &amp; a_{nn}<br>\end{pmatrix}<br>$$</p>
</li>
<li><p><strong>下三角（形）矩阵</strong>：主对角线以上的元全为$ 0 $的$ n $阶方阵.</p>
</li>
</ul>
<p>$$<br>\pmb{B} =<br>\begin{pmatrix}<br>b_{11} &amp; 0 &amp; \dots &amp; 0 \\<br>b_{21} &amp; b_{22} &amp; \dots &amp; 0 \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>b_{n1} &amp; b_{n2} &amp; \dots &amp; b_{nn}<br>\end{pmatrix}<br>$$</p>
<ul>
<li><p><strong>三角形矩阵</strong>：上三角形矩阵和下三角形矩阵统称为三角形矩阵.</p>
</li>
<li><p><strong>对角矩阵（diagonal matrix）</strong>：如果$ n $阶方阵的主对角线以外的元全为$ 0 $，则称为对角矩阵，记作$ \pmb{\Lambda} $或$ diag(a_{11} , a_{22} , \dots , a_{nn}) $.<br>$$<br>\pmb{\Lambda} =<br>\begin{pmatrix}<br>a_{11} &amp; &amp; &amp; \\<br>&amp; a_{22} &amp; &amp; \\<br>&amp;  &amp; \ddots &amp; \\<br>&amp;  &amp;  &amp; a_{nn}<br>\end{pmatrix}<br>$$</p>
</li>
</ul>
<blockquote>
<p>对角矩阵对角线上可以有零元.</p>
</blockquote>
<ul>
<li><p><strong>单位矩阵</strong>：主对角线上的元全为$ 1 $的$ n $阶对角矩阵称为$ n $阶单位矩阵，记作$ E_n $，$ I_n $或$ E $，$ I $.<br>$$<br>E = I =<br>\begin{pmatrix}<br>1 &amp; &amp; &amp; \\<br>&amp; 1 &amp; &amp; \\<br>&amp;  &amp; \ddots &amp; \\<br>&amp;  &amp;  &amp; 1<br>\end{pmatrix}<br>$$</p>
</li>
<li><p><strong>同型矩阵</strong>：两个行数与列数相等的矩阵.</p>
</li>
<li><p><strong>相等矩阵</strong>：设 $ \pmb{A}=(a_{ij})_{m\times n} $与$ \pmb{B}= (a_{ij})_{m\times n} $是同型矩阵且对应元相等，则称$ \pmb{A} $与$ \pmb{B} $相等，记作$ \pmb{A} = \pmb{B} $.即</p>
</li>
</ul>
<p>$$<br>\pmb{A} = \pmb{B} \Leftrightarrow a_{ij} = b_{ij},i=1,2,…,m;j=1,2,…,n.<br>$$</p>
<ul>
<li><strong>系数矩阵</strong>：在实际问题中，常常会遇到一些变量要用另外一些变量线性表示.设一组变量$ y_1 , y_2 ,…, y_m $用另一组变量$ x_1 , x_2 ,…, x_n $表示为<br>$$<br>\left \lbrace<br>\begin{aligned}<br>y_1 &amp; = a_{11}x_1+a_{12}x_2+…+a_{1n}x_n \\<br>y_2 &amp; = a_{21}x_1+a_{22}x_2+…+a_{2n}x_n \\<br>&amp; \dots \dots \dots \dots \\<br>y_m &amp; = a_{m1}x_1+a_{m2}x_2+…+a_{mn}x_n<br>\end{aligned}<br>\right.<br>$$</li>
</ul>
<p>称此关系式为从变量$ x_1 , x_2 ,…, x_n $到变量$ y_1 , y_2 ,…, y_m $的线性变换.</p>
<p>这个线性变换中的系数组成的矩阵$ {A} $称为此线性变换的系数矩阵.</p>
<p>$$<br>\pmb{A} =<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1} &amp; a_{m1} &amp; \dots &amp; a_{mn}<br>\end{pmatrix}<br>$$</p>
<h1 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h1><h2 id="矩阵的加法与数乘"><a href="#矩阵的加法与数乘" class="headerlink" title="矩阵的加法与数乘"></a>矩阵的加法与数乘</h2><blockquote>
<p><strong>定义</strong>：</p>
<p>设有两个同型的$ m\times n $矩阵$ \pmb{A}=(a_{ij}),\pmb{B}=(b_{ij}) $. 矩阵$ \pmb{A} $与$ \pmb{B} $的和记作$ \pmb{A}+\pmb{B} $，规定为</p>
<p>$$<br>\pmb{A}+\pmb{B} =<br>\begin{pmatrix}<br>a_{11}+b_{11} &amp; a_{12}+b_{12} &amp; \dots &amp; a_{1n}+b_{1n} \\<br>a_{21}+b_{21} &amp; a_{22}+b_{22} &amp; \dots &amp; a_{2n}+b_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1}+b_{m1} &amp; a_{m1}+b_{m1} &amp; \dots &amp; a_{mn}+b_{mn}<br>\end{pmatrix}<br>$$</p>
</blockquote>
<hr>
<blockquote>
<p><strong>定义</strong>：</p>
<p>数$ k $与矩阵$ \pmb{A} $的乘积，简称数乘，记作$ k\pmb{A} $或$ \pmb{A}k $,规定为</p>
<p>$$<br>k\pmb{A} = \pmb{A}k =<br>\begin{pmatrix}<br>ka_{11} &amp; ka_{12} &amp; \dots &amp; ka_{1n} \\<br>ka_{21} &amp; ka_{22} &amp; \dots &amp; ka_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>ka_{m1} &amp; ka_{m1} &amp; \dots &amp; ka_{mn}<br>\end{pmatrix}<br>$$</p>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>矩阵的加法与数乘统称为<strong>矩阵的线性运算</strong>.</li>
<li><strong>负矩阵</strong>：对于矩阵$ \pmb{A}= (a_{ij}) $, 称矩阵$ (-a_{ij}) $为$ \pmb{A} $的负矩阵，记作$ -\pmb{A} $.</li>
<li><strong>矩阵的减法</strong>：由负矩阵可以定义矩阵$ {A} $与$ {B} $的减法为$ \pmb{A}-\pmb{B} = \pmb{A}+(-\pmb{B}) $，即两个同型矩阵相减，归结为它们的对应元相减.</li>
<li>$ \pmb{A} = \pmb{B} \Leftrightarrow \pmb{A}-\pmb{B}=\pmb{O} $.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>性质</strong>：</p>
<p>矩阵的线性运算满足下列运算规律（设$ \pmb{A} , \pmb{B} , \pmb{C} $都是$ m\times n $矩阵，$ k $ 与$ l $ 为数）：</p>
<ol>
<li>$ \pmb{A}+\pmb{B}=\pmb{B}+\pmb{A} $.</li>
<li>$ (\pmb{A}+\pmb{B})+\pmb{C} = \pmb{A}+(\pmb{B}+\pmb{C}) $.</li>
<li>$ \pmb{A}+\pmb{O}=\pmb{A} $.</li>
<li>$ \pmb{A}+(-\pmb{A})=\pmb{O} $.</li>
<li>$ 1 \cdot \pmb{A} = \pmb{A} $.</li>
<li>$ (kl)\pmb{A}=k(l\pmb{A}) $.</li>
<li>$ (k+l)\pmb{A}=k\pmb{A}+l\pmb{A} $.</li>
<li>$ k(\pmb{A}+\pmb{B})=k\pmb{A}+k\pmb{B} $.</li>
</ol>
</blockquote>
<h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><blockquote>
<p><strong>定义</strong>：</p>
<p>设$ \pmb{A}=(a_{ij}) $是一个$ m\times s $矩阵，$ \pmb{B}=(b_{ij}) $是一个$ s\times n $矩阵，规定矩阵 $ \pmb{A} $与矩阵$ \pmb{B} $的乘积是$ m\times n $矩阵$ \pmb{C}=(c_{ij}) $，记为$ \pmb{C}=\pmb{AB} $,其中</p>
<p>$$<br>c_{ij} = a_{i1}b_{1j}+a_{i2}b_{2j}+…+a_{is}b_{sj}=\sum_{k=1}^{s} a_{ik}b_{kj}.(i=1,2,…,m;j=1,2,…,n)<br>$$</p>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>矩阵乘法不满足交换律，即在一般条件下，$ \pmb{AB} \neq \pmb{BA} $.        </li>
<li>两个非零矩阵之积可能是零矩阵.</li>
<li>若$ \pmb{A}\neq\pmb{O} $，$\pmb{AB}=\pmb{AC} $不能推出$ \pmb{B}=\pmb{C} $.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>性质</strong>：</p>
<p>矩阵的乘法满足下面的运算规律：</p>
<ul>
<li>$ (\pmb{AB})\pmb{C}=\pmb{A}(\pmb{BC}) $.</li>
<li>$ \pmb{A}(\pmb{B}+\pmb{C})=\pmb{AB}+\pmb{AC} , (\pmb{B}+\pmb{C})\pmb{A}=\pmb{BA}+\pmb{CA} $.</li>
<li>$ \lambda(\pmb{AB})=(\lambda\pmb{A})\pmb{B}=\pmb{A}(\lambda\pmb{B}) $，其中$ \lambda $是数.</li>
<li>$  \pmb{E}_m\pmb{A}_{m\times n} = \pmb{A}_{m\times n}\pmb{E}_n = \pmb{A}_{m\times n} $.</li>
</ul>
</blockquote>
<h2 id="方阵的幂与多项式"><a href="#方阵的幂与多项式" class="headerlink" title="方阵的幂与多项式"></a>方阵的幂与多项式</h2><p>设$ \pmb{A} $为$ n $阶方阵，$ k $为正整数，$ k $个$ \pmb{A} $的连乘积称为$ \pmb{A} $的$ k $次幂，记作$ \pmb{A}^k $.即</p>
<p>$$<br>\pmb{A}^k=\overbrace{\pmb{A}\pmb{A} … \pmb{A}}^{k}<br>$$</p>
<blockquote>
<p><strong>注意</strong>：$ \pmb{A}^0 = \pmb{E} $.</p>
</blockquote>
<hr>
<blockquote>
<p><strong>性质</strong>：</p>
<p>方阵的幂满足下面运算规律（$ \pmb{A} $为方阵，$ k,l $为非负整数）：</p>
<ul>
<li>$ \pmb{A}^k\pmb{A}^l=\pmb{A}^{k+l} $.</li>
<li>$ (\pmb{A}^k)^l=\pmb{A}^{kl} $.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：由于矩阵乘法不满足交换律，一般地，$ (\pmb{AB})^k\neq \pmb{A}^k\pmb{B}^k $.</p>
</blockquote>
<h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><h2 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h2><h2 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h2><h1 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h1><h1 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h1><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><h2 id="初等变换"><a href="#初等变换" class="headerlink" title="初等变换"></a>初等变换</h2><h1 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h1>]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「Markdown_03」使用Flowchart绘图</title>
    <url>/2016/09/10/markdown-03/</url>
    <content><![CDATA[<h1 id="安装Flowchart插件"><a href="#安装Flowchart插件" class="headerlink" title="安装Flowchart插件"></a>安装Flowchart插件</h1><ol>
<li><p>在<strong>Git Bash</strong>中输入<code>npm install --save hexo-filter-flowchart</code>。</p>
</li>
<li><p>如果没有特殊要求的话，不需要进行<code>.yml</code>文件的配置。</p>
</li>
<li><p>到这里，我们就可以通过<strong>添加代码块</strong>的方式来绘制图形了，这里要注意，添加的代码块要注明代码类型为<code>flow</code>。</p>
</li>
</ol>
<h1 id="绘制流程图"><a href="#绘制流程图" class="headerlink" title="绘制流程图"></a>绘制流程图</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>通用语法示意如下：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tag=&gt;type: content:&gt;url</span><br><span class="line">...</span><br><span class="line">tag1(...) -&gt; tag2(...) -&gt; tag3(...)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绘制流程图的代码分为两部分：<ol>
<li>定义元素</li>
<li>连接元素</li>
</ol>
</li>
</ol>
<h2 id="定义元素"><a href="#定义元素" class="headerlink" title="定义元素"></a>定义元素</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tag=&gt;type: content:&gt;url</span><br></pre></td></tr></table></figure>

<ol>
<li>代码中的元素含义为：<ul>
<li>tag：标签，即元素的名称；</li>
<li>type：元素的类型；</li>
<li>content：元素块中的内容；</li>
<li>url：链接，给元素上添加超链接。</li>
</ul>
</li>
<li>其中元素的类型有六种：<ul>
<li>start</li>
<li>end</li>
<li>operation</li>
<li>subroutine</li>
<li>condition</li>
<li>inputoutput</li>
</ul>
</li>
</ol>
<h2 id="连接元素"><a href="#连接元素" class="headerlink" title="连接元素"></a>连接元素</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tag1(...) -&gt; tag2(...) -&gt; tag3(...)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用<code>-&gt;</code>符号连接两个元素；</p>
</li>
<li><p>对于<code>condition</code>类型的元素，在标签后面用<code>(yes/no)</code>来表示其不同的<strong>分支</strong>；</p>
</li>
<li><p>对于<strong>被连接的</strong>元素，在标签后面用<code>(right/left)</code>来规定其<strong>位置</strong>；</p>
</li>
<li><p>对于<strong>被连接的</strong><code>condition</code>类型的元素，可以用<code>(yes/no, right/left)</code>来同时确定<strong>分支和位置</strong>。</p>
</li>
</ol>
<h2 id="综合效果"><a href="#综合效果" class="headerlink" title="综合效果"></a>综合效果</h2><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start|past:&gt;https://hengistyoo.github.io/</span><br><span class="line">e=&gt;end: End:&gt;https://hengistyoo.github.io/</span><br><span class="line">op1=&gt;operation: My Operation|past</span><br><span class="line">op2=&gt;operation: Stuff|current</span><br><span class="line">sub1=&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?|approved:&gt;https://hengistyoo.github.io/</span><br><span class="line">c2=&gt;condition: Good idea|rejected</span><br><span class="line">io=&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<div id="flowchart-0" class="flow-chart"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>https://hengistyoo.github.io/
e=>end: End:>https://hengistyoo.github.io/
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>https://hengistyoo.github.io/
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>进阶语法</tag>
        <tag>Flowchart</tag>
      </tags>
  </entry>
  <entry>
    <title>「Markdown_02」使用Mermaid绘图</title>
    <url>/2016/09/05/markdown-02/</url>
    <content><![CDATA[<h1 id="安装Mermaid插件"><a href="#安装Mermaid插件" class="headerlink" title="安装Mermaid插件"></a>安装Mermaid插件</h1><ol>
<li>在<strong>Git Bash</strong>中输入<code>npm install --save hexo-filter-mermaid-diagrams</code>。</li>
<li>在Hexo的<code>config.yml</code>文件末尾添加以下内容：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">"7.1.2"</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>YOURBLOG/themes/YOURTHEME/layout</code>文件夹中寻找<code>footer.ejs</code>文件，即你的博客下，你正在应用的主题中的<code>layout</code>文件夹中的<code>footer.ejs</code>文件。这个文件的名称可能与<code>footer</code>有出入，但是名称中应当包含<code>footer</code>。在文件末尾添加以下内容：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">  &lt;script src=<span class="string">'https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    if (window.mermaid) &#123;</span></span><br><span class="line"><span class="regexp">      mermaid.initialize(&#123;theme: 'forest'&#125;);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>forest</code>是绘图的主题，不同主题的色彩组合不同，共4种主题可以选择，分别是<code>default</code>、<code>dark</code>、<code>forest</code>、<code>neutral</code>。</p>
<ol start="4">
<li>到这里，我们就可以通过<strong>添加代码块</strong>的方式来绘制图形了，这里要注意，添加的代码块要注明代码类型为<code>mermaid</code>。</li>
</ol>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="三种基本线型"><a href="#三种基本线型" class="headerlink" title="三种基本线型"></a>三种基本线型</h2><h3 id="基本线型"><a href="#基本线型" class="headerlink" title="基本线型"></a>基本线型</h3><p>节点之间通过连线来连接，一共有<strong>三种</strong>线型：虚线<code>-.-</code>、实线<code>---</code>、粗实线<code>===</code>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A1 -.- A2</span><br><span class="line">B1 --- B2</span><br><span class="line">C1 === C2</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">graph TB
A1 -.- A2
B1 --- B2
C1 === C2</pre>

<h3 id="带箭头的线型"><a href="#带箭头的线型" class="headerlink" title="带箭头的线型"></a>带箭头的线型</h3><p>在基本线型符号串的右边加上<code>&gt;</code>符号，<strong>去掉左边第1个符号</strong>，使其<strong>仍然保持3个符号</strong>，就获得了带箭头的线型。其中虚线的第一个符号可以不去掉。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A1 .-&gt; A2</span><br><span class="line">B1 --&gt; B2</span><br><span class="line">C1 ==&gt; C2</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph TB
A1 .-> A2
B1 --> B2
C1 ==> C2</pre>

<h3 id="带说明文字的线型"><a href="#带说明文字的线型" class="headerlink" title="带说明文字的线型"></a>带说明文字的线型</h3><p>基本线型和带箭头的线型可以进行组合，中间加上说明文字即可。其中，说明文字左侧的基本线型只取<strong>前两个</strong>符号。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A1 -. 说明文字 -.- A2</span><br><span class="line">B1 -. 说明文字 .-&gt; B2</span><br><span class="line">C1 -- 说明文字 --- C2</span><br><span class="line">D1 -- 说明文字 --&gt; D2</span><br><span class="line">E1 == 说明文字 === E2</span><br><span class="line">F1 == 说明文字 ==&gt; F2</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">graph TB
A1 -. 说明文字 -.- A2
B1 -. 说明文字 .-> B2
C1 -- 说明文字 --- C2
D1 -- 说明文字 --> D2
E1 == 说明文字 === E2
F1 == 说明文字 ==> F2</pre>

<h2 id="四种图形走向"><a href="#四种图形走向" class="headerlink" title="四种图形走向"></a>四种图形走向</h2><p>所有节点之间的连线，都具有方向性，方向共以下四种：</p>
<ul>
<li>TB/TD：从上到下；</li>
<li>BT：从下到上；</li>
<li>LR：从左到右；</li>
<li>RL：从右到左。</li>
</ul>
<p>效果如下：</p>
<pre class="mermaid">graph TB
A1 --> A2</pre>

<pre class="mermaid">graph BT
A1 --> A2</pre>

<pre class="mermaid">graph LR
A1 --> A2</pre>

<pre class="mermaid">graph RL
A1 --> A2</pre>

<h2 id="五种节点形状"><a href="#五种节点形状" class="headerlink" title="五种节点形状"></a>五种节点形状</h2><p>节点默认是矩形的，但是可以通过语法来选定节点的形状，语法如下表。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>形状</th>
</tr>
</thead>
<tbody><tr>
<td>[ ]</td>
<td>矩形</td>
</tr>
<tr>
<td>( )</td>
<td>圆角矩形</td>
</tr>
<tr>
<td>(( ))</td>
<td>圆形</td>
</tr>
<tr>
<td>{ }</td>
<td>菱形</td>
</tr>
<tr>
<td>&gt; ]</td>
<td>非对称节点</td>
</tr>
</tbody></table>
<p>效果如下：</p>
<pre class="mermaid">graph LR
A[A] --- B(B)
B --- C((C))
C --- D{D}
D --- E>E]</pre>

<h2 id="子图形"><a href="#子图形" class="headerlink" title="子图形"></a>子图形</h2><p>子图形可以被嵌入图形中，以<code>subgraph</code>开始，以<code>end</code>结束。另外，子图形<strong>必须提供标题</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A--&gt;D</span><br><span class="line">A--&gt;F</span><br><span class="line">subgraph 图三</span><br><span class="line">C--&gt;D</span><br><span class="line">C--&gt;G((G))</span><br><span class="line">end</span><br><span class="line">subgraph 图二</span><br><span class="line">A---B</span><br><span class="line">end</span><br><span class="line">subgraph 图一</span><br><span class="line">E-.-F</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">graph TB
A-->D
A-->F
subgraph 图三
C-->D
C-->G((G))
end
subgraph 图二
A---B
end
subgraph 图一
E-.-F
end</pre>

<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><h2 id="定义角色"><a href="#定义角色" class="headerlink" title="定义角色"></a>定义角色</h2><p>用<code>participant</code>来定义参与者，用<code>as</code>来增加角色的别名。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">participant A</span><br><span class="line">panticipant B as C</span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li>定义角色不是必须的，参与者<strong>按照出场先后顺序排列</strong>，如果要把某个角色排在前面，就要定义他。</li>
<li>定义语句不一定要在消息传递之前，放在中间或者后面都可以。</li>
</ul>
<h2 id="消息连线"><a href="#消息连线" class="headerlink" title="消息连线"></a>消息连线</h2><h3 id="基本线型-1"><a href="#基本线型-1" class="headerlink" title="基本线型"></a>基本线型</h3><p>用<code>-&gt;</code>表示实线，用<code>--&gt;</code>表示虚线。</p>
<h3 id="带箭头的线型-1"><a href="#带箭头的线型-1" class="headerlink" title="带箭头的线型"></a>带箭头的线型</h3><p>用<code>-&gt;&gt;</code>表示带箭头的实线，用<code>–-&gt;&gt;</code>表示带箭头的虚线。</p>
<h3 id="带终止符的线型"><a href="#带终止符的线型" class="headerlink" title="带终止符的线型"></a>带终止符的线型</h3><p>用<code>-&gt;&gt;</code>表示带终止符的实线，用<code>–-&gt;&gt;</code>表示带终止符的虚线。</p>
<h3 id="综合效果"><a href="#综合效果" class="headerlink" title="综合效果"></a>综合效果</h3><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt; B:实线</span><br><span class="line">B --&gt; A:虚线</span><br><span class="line">A -&gt;&gt; B:实线箭头</span><br><span class="line">B --&gt;&gt; A:虚线箭头</span><br><span class="line">A -x B:实线终止符</span><br><span class="line">B --x A:虚线终止符</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A -> B:实线
B --> A:虚线
A ->> B:实线箭头
B -->> A:虚线箭头
A -x B:实线终止符
B --x A:虚线终止符</pre>

<h2 id="角色内部任务"><a href="#角色内部任务" class="headerlink" title="角色内部任务"></a>角色内部任务</h2><p>角色本身不仅传递消息，自身还存在任务，需要告诉他<strong>开始处理</strong>及<strong>处理完</strong>自己的任务。开始处理用<code>activate</code>，处理完毕用<code>deactivate</code>。</p>
<p>多数情况下，都是角色在<strong>接收到消息时</strong>才会启动或者结束自身任务，因此有一个快捷的办法，<strong>在消息连线后面加上+/-</strong>，表示接收消息的角色这时候应该<strong>开始/结束</strong>自身任务处理。</p>
<p>另外，如果有多个启动和完成任务的指令，记住他们一定是从最内侧进行配对的。</p>
<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt;&gt;+ B:B启动任务1</span><br><span class="line">B --&gt;&gt; A:消息</span><br><span class="line">activate B</span><br><span class="line">B --&gt;&gt; A:上一句让B启动了任务2。</span><br><span class="line">A -&gt;&gt;- B:B结束了任务，只能匹配任务2</span><br><span class="line">B --x A:这里有个终止符</span><br><span class="line">deactivate B</span><br><span class="line">A -x B:上一句B结束了任务，只能匹配任务1</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A ->>+ B:B启动任务1
B -->> A:消息
activate B
B -->> A:上一句让B启动了任务2。
A ->>- B:B结束了任务，只能匹配任务2
B --x A:这里有个终止符
deactivate B
A -x B:上一句B结束了任务，只能匹配任务1</pre>



<h2 id="贴标签"><a href="#贴标签" class="headerlink" title="贴标签"></a>贴标签</h2><p>给角色贴上便签<code>Note</code>，便签的位置有角色的左边、右边或者上方，但是<strong>没有下方</strong>。</p>
<p>语法是<code>Note left of/right of/over A/B/A,B : Text</code>，要注意的是，只有<code>over</code>后面可以跟随多个对象。</p>
<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">Note over A:A的标签</span><br><span class="line">A -&gt;&gt; B:消息</span><br><span class="line">Note left of A:A的标签</span><br><span class="line">Note right of B:B的标签</span><br><span class="line">B --&gt;&gt; A:消息</span><br><span class="line">Note over A,B:A、B的标签</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
Note over A:A的标签
A ->> B:消息
Note left of A:A的标签
Note right of B:B的标签
B -->> A:消息
Note over A,B:A、B的标签</pre>

<h2 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h2><p>时序在处理的时候，肯定会遇上有条件执行的情况，它的语法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">alt 可选语句说明</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>其中的<code>alt</code>是<code>alternative</code>的缩写，即这有两组时序是二选一的，相当于<code>if-else</code>语句。如果没有<code>else</code>，那么用另外一个关键词<code>opt</code>，它是<code>optional</code>的缩写，语法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">opt 条件说明</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt;&gt; B: 你好吗？</span><br><span class="line">alt 如果B很好</span><br><span class="line">B --&gt;&gt; A:我很好</span><br><span class="line">else</span><br><span class="line">B --&gt;&gt; A:我不好</span><br><span class="line">end</span><br><span class="line">B -&gt;&gt; A:你有空吗？咱看电影去。</span><br><span class="line">opt A有空</span><br><span class="line">A --&gt;&gt; B: 去吧</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A ->> B: 你好吗？
alt 如果B很好
B -->> A:我很好
else
B -->> A:我不好
end
B ->> A:你有空吗？咱看电影去。
opt A有空
A -->> B: 去吧
end</pre>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>把几个语句用<code>loop end</code>语句圈起来，这就是时序循环。语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop 循环语句说明</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt;&gt; B: 有人在吗</span><br><span class="line">B -&gt;&gt; A: 在啊</span><br><span class="line">loop 这俩话痨</span><br><span class="line">A --&gt;&gt; B: 你好</span><br><span class="line">B --&gt;&gt; A: 你好</span><br><span class="line">end</span><br><span class="line">A -&gt;&gt; B: 我不玩了，只会说你好</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A ->> B: 有人在吗
B ->> A: 在啊
loop 这俩话痨
A -->> B: 你好
B -->> A: 你好
end
A ->> B: 我不玩了，只会说你好</pre>



<h1 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="时间及项目标题"><a href="#时间及项目标题" class="headerlink" title="时间及项目标题"></a>时间及项目标题</h3><ul>
<li>时间格式为<code>dateFormat YYYY-MM-DD</code>，定义图中坐标轴的时间格式，可供选择的字符串格式在<a href="http://momentjs.com/docs/#/parsing/string-format/" target="_blank" rel="noopener">这里</a>。</li>
<li>项目标题为<code>title &lt;project title&gt;</code>，项目的标题，中间可以用空格。</li>
</ul>
<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><ul>
<li>阶段为<code>section &lt;phase name&gt;</code>,描述性字符串中间可以加空格。</li>
</ul>
<h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">活动名</span>&gt;</span></span>:[重要等级],[完成状态],[激活状态],[活动的引用名],[开始时间/依赖],[结束时间/持续时间]</span><br></pre></td></tr></table></figure>

<ul>
<li>活动名：必须。用于描述活动的内容或性质，中间可以包括空格，但不可包含<code>:</code>，因为冒号被用作与后面各项的分隔符。</li>
<li>重要等级：非必须。如果非常重要，则取值<code>crit</code> ，可为空。</li>
<li>完成状态：非必须。如果已完成，则用<code>done</code>表示，可为空。</li>
<li>激活状态：非必须。如果已激活，则为<code>active</code>，可为空。</li>
<li>活动引用名：非必须。给当前活动指定引用名称，以便下方引用，名称中<strong>不能包含空格</strong>。</li>
<li>开始时间：非必须。可以取绝对时间或相对时间。相对时间用<code>after</code>关键字。表示在另外一个活动完成之后开始，如果没有指定，则<strong>默认为上个活动结束的时间</strong>。</li>
<li>结束时间/持续时间：必须。可以是绝对时间，前提是<strong>它的前面应该是绝对时间</strong>。也可以是持续时间。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">title 软件开发甘特图</span><br><span class="line">section 设计</span><br><span class="line">  需求: done, des1, 2014-01-06, 2014-01-08</span><br><span class="line">  原型: active, des2, 2014-01-09, 3d</span><br><span class="line">  UI设计: des3, after des2, 5d</span><br><span class="line">  未来任务: des4, after des3, 5d</span><br><span class="line">section 开发</span><br><span class="line">  学习准备理解需求: crit, done, 2014-01-06, 24h</span><br><span class="line">  设计框架: crit, done, after des2, 2d</span><br><span class="line">  开发: crit, active, 3d</span><br><span class="line">  未来任务: crit, 5d</span><br><span class="line">  耍: 2d</span><br><span class="line">section 测试</span><br><span class="line">  功能测试: active, a1, after des3, 3d</span><br><span class="line">  压力测试: after a1, 20h</span><br><span class="line">  测试报告: 48h</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">gantt
dateFormat  YYYY-MM-DD
title 软件开发甘特图
section 设计
  需求: done, des1, 2014-01-06, 2014-01-08
  原型: active, des2, 2014-01-09, 3d
  UI设计: des3, after des2, 5d
  未来任务: des4, after des3, 5d
section 开发
  学习准备理解需求: crit, done, 2014-01-06, 24h
  设计框架: crit, done, after des2, 2d
  开发: crit, active, 3d
  未来任务: crit, 5d
  耍: 2d
section 测试
  功能测试: active, a1, after des3, 3d
  压力测试: after a1, 20h
  测试报告: 48h</pre>

<h1 id="类结构图"><a href="#类结构图" class="headerlink" title="类结构图"></a>类结构图</h1><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class01 <span class="xml"><span class="tag">&lt;<span class="name">|--</span> <span class="attr">AveryLongClass</span> <span class="attr">:</span> <span class="attr">Cool</span></span></span></span><br><span class="line"><span class="xml">Class03 *-- Class04</span></span><br><span class="line"><span class="xml">Class05 o-- Class06</span></span><br><span class="line"><span class="xml">Class07 .. Class08</span></span><br><span class="line"><span class="xml">Class09 --&gt;</span> C2 : Where am i?</span><br><span class="line">Class09 --* C3</span><br><span class="line">Class09 --|&gt; Class07</span><br><span class="line">Class07 : equals()</span><br><span class="line">Class07 : Object[] elementData</span><br><span class="line">Class01 : size()</span><br><span class="line">Class01 : int chimp</span><br><span class="line">Class01 : int gorilla</span><br><span class="line">Class08 <span class="xml"><span class="tag">&lt;<span class="name">--</span>&gt;</span></span> C2: Cool label</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">classDiagram
Class01 <|-- AveryLongClass : Cool
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 --> C2 : Where am i?
Class09 --* C3
Class09 --|> Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
Class08 <--> C2: Cool label</pre>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>进阶语法</tag>
        <tag>Mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>「Markdown_01」基本语法</title>
    <url>/2016/09/01/markdown-01/</url>
    <content><![CDATA[<h1 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h1><h2 id="通用标题设置"><a href="#通用标题设置" class="headerlink" title="通用标题设置"></a>通用标题设置</h2><p>使用<code>#</code>符号来设置<strong>不同级别</strong>的标题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h2 id="前两级标题设置"><a href="#前两级标题设置" class="headerlink" title="前两级标题设置"></a>前两级标题设置</h2><p><strong>一级标题</strong>使用<code>=</code>来设置，<strong>二级标题</strong>使用<code>-</code>来设置。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">===</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p>&nbsp;</p>
<h1 id="自然段换行"><a href="#自然段换行" class="headerlink" title="自然段换行"></a>自然段换行</h1><h2 id="新的自然段"><a href="#新的自然段" class="headerlink" title="新的自然段"></a>新的自然段</h2><p>只需要在两个自然段之间<strong>空一行</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第一段</span><br><span class="line"></span><br><span class="line">第二段</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>第一段</p>
<p>第二段</p>
</blockquote>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>在<strong>行末</strong>加<strong>两个空格</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第一行  </span><br><span class="line">第二行</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>第一行<br>第二行</p>
</blockquote>
<p>&nbsp;</p>
<h1 id="引用表现"><a href="#引用表现" class="headerlink" title="引用表现"></a>引用表现</h1><p>在<strong>行首</strong>加<code>&gt;</code>即可添加引用格式。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用这段话</span></span><br><span class="line">&gt;&gt;&gt; 多重引用这段话</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>引用这段话</p>
<blockquote>
<blockquote>
<p>多重引用这段话</p>
</blockquote>
</blockquote>
</blockquote>
<p>&nbsp;</p>
<h1 id="增加分割线"><a href="#增加分割线" class="headerlink" title="增加分割线"></a>增加分割线</h1><p>使用<code>---</code>、<code>***</code>、<code>___</code>、<code>- - -</code>都可以为文章增加分割线，其中<code>---</code><strong>与二级标题的区别</strong>在于，二级标题的<code>---</code>上一行是文字，而分割线的上一行是空行。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">___</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>- -</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<hr>
<hr>
<hr>
<hr>
</blockquote>
<p>&nbsp;</p>
<h1 id="强调表现"><a href="#强调表现" class="headerlink" title="强调表现"></a>强调表现</h1><p>将<strong>单个</strong><code>*</code> 或<code>_</code>加在文字两侧，就是<strong>斜体</strong>；将<strong>连续两个</strong><code>*</code> 或<code>_</code>加在文字两侧，就是<strong>粗体</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span> <span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**粗体**</span> <span class="strong">__粗体__</span></span><br><span class="line"><span class="strong">***粗斜体**</span>* <span class="strong">___粗斜体__</span>_</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><em>斜体</em> <em>斜体</em><br><strong>粗体</strong> <strong>粗体</strong><br><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p>
</blockquote>
<p>&nbsp;</p>
<h1 id="列表表现"><a href="#列表表现" class="headerlink" title="列表表现"></a>列表表现</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>将<code>-</code>、<code>*</code>、<code>+</code>符号置于行首，用<strong>两个空格分等级</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">  - </span>无序列表</span><br><span class="line"><span class="bullet">    - </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<ul>
<li>无序列表<ul>
<li>无序列表<ul>
<li>无序列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
</blockquote>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>用<strong>后面带<code>.</code>的数字</strong>置于行首，用两个空格分级。有序列表会<strong>从第一个条目前面的数字开始排序</strong>，为了便于插入新的条目，建议第一个条目用<code>1</code>，其他条目用<code>0</code>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>有序列表</span><br><span class="line"><span class="bullet">0. </span>有序列表</span><br><span class="line"><span class="bullet">  1. </span>有序列表</span><br><span class="line"><span class="bullet">  0. </span>有序列表</span><br><span class="line"><span class="bullet">  0. </span>有序列表</span><br><span class="line"><span class="bullet">0. </span>有序列表</span><br><span class="line"><span class="bullet">0. </span>有序列表</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<ol>
<li>有序列表</li>
<li>有序列表<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
</blockquote>
<p>&nbsp;</p>
<h1 id="超文本链接"><a href="#超文本链接" class="headerlink" title="超文本链接"></a>超文本链接</h1><p>超文本链接有以下四种写法，<strong>前两种写法</strong>会将链接直接显示出来，<strong>第三种写法</strong>可以显示指定的文字，<strong>第四种写法</strong>可以增加一个鼠标悬停的标题。 </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">https://hengistyoo.github.io/</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">hengistyoo.github.io</span>/&gt;</span></span></span><br><span class="line">[<span class="string">豆豆的小笔记</span>](<span class="link">https://hengistyoo.github.io/</span>)</span><br><span class="line">[<span class="string">豆豆的小笔记</span>](<span class="link">https://hengistyoo.github.io/ "你好呀，我是豆豆！"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><a href="https://hengistyoo.github.io/">https://hengistyoo.github.io/</a><br><a href="https://hengistyoo.github.io/">https://hengistyoo.github.io/</a><br><a href="https://hengistyoo.github.io/">豆豆的小笔记</a><br><a href="https://hengistyoo.github.io/" title="你好呀，我是豆豆！">豆豆的小笔记</a></p>
</blockquote>
<p>&nbsp;</p>
<h1 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h1><h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>用反单引号<code>`</code>符号来引用，如果要引用反单引号，则可以使用<strong>一对两个反单引号</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">您可以使用<span class="code">`add(x,y)`</span>函数计算两个数的和。</span><br><span class="line">反单引号是<span class="code">```</span>`` 。</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>您可以使用<code>add(x,y)</code>函数计算两个数的和。<br>反单引号是<code>`</code>。</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>用<strong>连续三个</strong><code>`</code>或<code>~</code>来显示代码块，可以在第一行末尾注明代码的语言名。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```</span>c++</span><br><span class="line">int main()&#123;</span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">效果如下：</span><br><span class="line"></span><br><span class="line">&gt; &#96;&#96;&#96;c++</span><br><span class="line">&gt; int main()&#123;</span><br><span class="line">&gt;     return 0;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>


<p>&nbsp;</p>
<h1 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h1><h2 id="无链接图片"><a href="#无链接图片" class="headerlink" title="无链接图片"></a>无链接图片</h2><p>使用<code>![]()</code>来显示图片，方括号中填写的是<strong>alt文字</strong>，即在找不到图片或图片加载出来之前显示的文字；圆括号中填写的是<strong>图片url</strong>和<strong>图片title</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Doge</span>](<span class="link">dog.jpeg "狗子"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><img src="dog.jpeg" alt="Doge" title="狗子"></p>
</blockquote>
<h2 id="带链接图片"><a href="#带链接图片" class="headerlink" title="带链接图片"></a>带链接图片</h2><p>将<strong>超链接的语法套在图片的语法上</strong>，即<code>[![]()]()</code>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![Doge</span>](<span class="link">dog.jpeg "狗子"</span>)](<span class="link">https://hengistyoo.github.io/ "你好呀，我是豆豆！"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><a href="https://hengistyoo.github.io/" title="你好呀，我是豆豆！"><img src="dog.jpeg" alt="Doge" title="狗子"></a></p>
</blockquote>
<p>&nbsp;</p>
<h1 id="表格显示"><a href="#表格显示" class="headerlink" title="表格显示"></a>表格显示</h1><h2 id="表格制作"><a href="#表格制作" class="headerlink" title="表格制作"></a>表格制作</h2><p>使用<code>-</code>和<code>|</code>来制作表格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| TH1  | TH2  | TH3  |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| TD1  | TD2  | TD3  |</span><br><span class="line">| TD4  | TD5  | TD6  |</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>TH1</th>
<th>TH2</th>
<th>TH3</th>
</tr>
</thead>
<tbody><tr>
<td>TD1</td>
<td>TD2</td>
<td>TD3</td>
</tr>
<tr>
<td>TD4</td>
<td>TD5</td>
<td>TD6</td>
</tr>
</tbody></table>
<h2 id="表格对齐"><a href="#表格对齐" class="headerlink" title="表格对齐"></a>表格对齐</h2><p>使用<code>:</code>来实现表格对齐。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| TH1  | TH2  | TH3  |</span><br><span class="line">| :--- | :---: | ---: |</span><br><span class="line">| TD1  | TD2  | TD3  |</span><br><span class="line">| TD4  | TD5  | TD6  |</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th align="left">TH1</th>
<th align="center">TH2</th>
<th align="right">TH3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TD1</td>
<td align="center">TD2</td>
<td align="right">TD3</td>
</tr>
<tr>
<td align="left">TD4</td>
<td align="center">TD5</td>
<td align="right">TD6</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hexo_01」使用Hexo搭建Blog</title>
    <url>/2016/08/26/hexo-01/</url>
    <content><![CDATA[<h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>Node.js是一个基于Chrome V8引擎的<strong>JavaScript运行环境</strong>。需要进入<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a>下载安装。</p>
<p>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</p>
<p>其它的安装方法：</p>
<ul>
<li>Windows：通过 nvs（推荐）或者nvm 安装。</li>
<li>Mac：使用 Homebrew 或 MacPorts 安装。</li>
<li>Linux（DEB/RPM-based）：从 NodeSource 安装。</li>
<li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导</li>
</ul>
<p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p>
<blockquote>
<p>Windows 用户</p>
<p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p>
</blockquote>
<blockquote>
<p>For Mac / Linux 用户</p>
<p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">由 npmjs 发布的指导</a> 修复该问题。强烈建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p>
</blockquote>
<blockquote>
<p><strong>测试安装成功</strong>需要在<code>cmd</code>中输入<code>node -v</code>，输出Node.js的版本号即为安装成功。</p>
</blockquote>
<h1 id="注册代码托管平台"><a href="#注册代码托管平台" class="headerlink" title="注册代码托管平台"></a>注册代码托管平台</h1><blockquote>
<p>为了后期部署方便，这里建议使用<strong>同一个</strong>邮箱来注册不同平台。</p>
</blockquote>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ol>
<li>登录<a href="https://github.com/" target="_blank" rel="noopener">GitHub网站</a>注册GitHub账号。</li>
<li>点击<strong>New repository</strong>按钮新建仓库，仓库命名要和GitHub的用户名<strong>保持一致</strong>，例如我的GitHub的用户名为<strong>HengistYoo</strong>，我这里的仓库名就叫做<strong>HengistYoo.github.io</strong>。仓库的其他参数保持默认即可。</li>
</ol>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><ol>
<li>登录<a href="https://gitee.com/" target="_blank" rel="noopener">码云网站</a>注册账号。</li>
<li>点击<strong>新建仓库</strong>按钮新建仓库，仓库命名要和Gitee的用户名<strong>保持一致</strong>，例如我的Gitee的用户名为<strong>HengistYoo</strong>，我这里的仓库名就叫做<strong>HengistYoo</strong>，注意这里的命名<strong>和GitHub不同</strong>。仓库的其他参数保持默认即可。</li>
</ol>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><ul>
<li>Windows：下载并安装 git.</li>
<li>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</li>
<li>Linux (Ubuntu, Debian)：sudo apt-get install git-core</li>
<li>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</li>
</ul>
<blockquote>
<p><strong>Mac 用户</strong><br>如果在编译时可能会遇到问题，请先到App Store安装Xcode，Xcode完成后，启动并进入Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install安装命令行工具。</p>
</blockquote>
<blockquote>
<p><strong>Windows 用户</strong><br>对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝 Git for Windows 镜像</a>下载 git 安装包。</p>
</blockquote>
<blockquote>
<p><strong>测试安装成功</strong>需要在<code>cmd</code>中输入<code>git --version</code>，输出Git的版本号即为安装成功。</p>
</blockquote>
<h1 id="托管平台SSH配置"><a href="#托管平台SSH配置" class="headerlink" title="托管平台SSH配置"></a>托管平台SSH配置</h1><blockquote>
<p>上传代码可以通过远程SSH链接，其中使用SSH Keys来进行远程登录安全验证。</p>
</blockquote>
<p>在Git bash中输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"name@xx.com"</span></span><br></pre></td></tr></table></figure>

<p>其中，最后一个参数输入注册GitHub和Gitee的邮箱，然后一路回车，就可以创建SSH Key。</p>
<p>到<code>C:\Users\YOURNAME\.ssh</code>路径下，将<code>id_rsa.pub</code>文件的内容添加到GitHub和Gitee的SSH Key当中。</p>
<h1 id="更换npm源"><a href="#更换npm源" class="headerlink" title="更换npm源"></a>更换npm源</h1><p>后面要用到npm命令下载一些文件，直接访问速度比较慢，因此这里将npm源更换为国内的<strong>淘宝源</strong>。</p>
<h2 id="单次使用"><a href="#单次使用" class="headerlink" title="单次使用"></a>单次使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="永久使用"><a href="#永久使用" class="headerlink" title="永久使用"></a>永久使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>检查是否配置成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<p>如果要还原：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>

<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>在想要安装Hexo的路径下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init YOURBLOGNAME</span><br><span class="line"><span class="built_in">cd</span> YOURBLOGNAME</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
