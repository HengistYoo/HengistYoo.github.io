<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>「Go_07」流程控制</title>
    <url>/2020/03/10/go-07/</url>
    <content><![CDATA[<p>流程控制是每种编程语言控制逻辑走向和执行次序的重要部分，流程控制可以说是一门语言的“经脉”。</p>
<p>Go语言中最常用的流程控制有<code>if</code>和<code>for</code>，而<code>switch</code>和<code>goto</code>主要是为了简化代码、降低重复代码而生的结构，属于<strong>扩展类</strong>的流程控制。</p>
<h1 id="if-else-分支结构"><a href="#if-else-分支结构" class="headerlink" title="if else | 分支结构"></a>if else | 分支结构</h1><h2 id="if条件判断基本写法"><a href="#if条件判断基本写法" class="headerlink" title="if条件判断基本写法"></a>if条件判断基本写法</h2><p>Go语言中<code>if</code>条件判断的格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span> &#123;</span><br><span class="line">    分支<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> 表达式<span class="number">2</span> &#123;</span><br><span class="line">    分支<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    分支<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当表达式1的结果为<code>true</code>时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 </li>
<li><code>if</code>判断中的<code>else if</code>和<code>else</code>都是可选的，可以根据实际需要进行选择。</li>
<li>Go语言规定与<code>if</code>匹配的左括号<code>{</code>必须与<code>if</code>和表达式放在同一行，<code>{</code>放在其他位置会触发编译错误。</li>
<li>同理，与<code>else</code>匹配的<code>{</code>也必须与<code>else</code>写在同一行，<code>else</code>也必须与上一个<code>if</code>或<code>else if</code>右边的大括号在同一行。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	score := <span class="number">65</span></span><br><span class="line">	<span class="keyword">if</span> score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if条件判断特殊写法"><a href="#if条件判断特殊写法" class="headerlink" title="if条件判断特殊写法"></a>if条件判断特殊写法</h2><p><code>if</code>条件判断还有一种特殊的写法，可以在<code>if</code>表达式之前添加一个执行语句，再根据变量值进行判断。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ifDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> score := <span class="number">65</span>; score &gt;= <span class="number">90</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> score &gt; <span class="number">75</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="for-循环结构"><a href="#for-循环结构" class="headerlink" title="for | 循环结构"></a>for | 循环结构</h1><p>Go 语言中的<strong>所有循环类型</strong>均可以使用<code>for</code>关键字来完成。</p>
<h2 id="for循环基本写法"><a href="#for循环基本写法" class="headerlink" title="for循环基本写法"></a>for循环基本写法</h2><p><code>for</code>循环的基本格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 初始语句;条件表达式;结束语句&#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>条件表达式返回<code>true</code>时循环体不停地进行循环，直到条件表达式返回<code>false</code>时自动退出循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for循环省略初始语句"><a href="#for循环省略初始语句" class="headerlink" title="for循环省略初始语句"></a>for循环省略初始语句</h2><p><code>for</code>循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for循环省略初始语句和结束语句"><a href="#for循环省略初始语句和结束语句" class="headerlink" title="for循环省略初始语句和结束语句"></a>for循环省略初始语句和结束语句</h2><p><code>for</code>循环的初始语句和结束语句都可以省略，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法类似于其他编程语言中的<code>while</code>，在<code>while</code>后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。</p>
<h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    循环体语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code>循环可以通过<code>break</code>、<code>goto</code>、<code>return</code>、<code>panic</code>语句强制退出循环。</p>
<h2 id="for-range-键值循环"><a href="#for-range-键值循环" class="headerlink" title="for range | 键值循环"></a>for range | 键值循环</h2><p>Go语言中可以使用<code>for range</code>遍历<strong>数组</strong>、<strong>切片</strong>、<strong>字符串</strong>、<strong>map</strong>及<strong>通道</strong>（channel）。 </p>
<p>通过<code>for range</code>遍历的返回值有以下规律：</p>
<ol>
<li>数组、切片、字符串返回索引和值。</li>
<li>map返回键和值。</li>
<li>通道（channel）只返回通道内的值。</li>
</ol>
<h1 id="switch-case-简化判断"><a href="#switch-case-简化判断" class="headerlink" title="switch case | 简化判断"></a>switch case | 简化判断</h1><p>使用<code>switch</code>语句可方便地对大量的值进行条件判断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	finger := <span class="number">3</span></span><br><span class="line">	<span class="keyword">switch</span> finger &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		fmt.Println(<span class="string">"大拇指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">"食指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		fmt.Println(<span class="string">"中指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		fmt.Println(<span class="string">"无名指"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">		fmt.Println(<span class="string">"小拇指"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"无效的输入！"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言规定每个<code>switch</code>只能有一个<code>default</code>分支。</p>
<p>一个分支可以有多个值，多个<code>case</code>值中间使用英文逗号分隔。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testSwitch3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> n := <span class="number">7</span>; n &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>:</span><br><span class="line">		fmt.Println(<span class="string">"奇数"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>:</span><br><span class="line">		fmt.Println(<span class="string">"偶数"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分支还可以使用表达式，这时候<code>switch</code>语句后面不需要再跟判断变量。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo4</span><span class="params">()</span></span> &#123;</span><br><span class="line">	age := <span class="number">30</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> age &lt; <span class="number">25</span>:</span><br><span class="line">		fmt.Println(<span class="string">"好好学习吧"</span>)</span><br><span class="line">	<span class="keyword">case</span> age &gt; <span class="number">25</span> &amp;&amp; age &lt; <span class="number">35</span>:</span><br><span class="line">		fmt.Println(<span class="string">"好好工作吧"</span>)</span><br><span class="line">	<span class="keyword">case</span> age &gt; <span class="number">60</span>:</span><br><span class="line">		fmt.Println(<span class="string">"好好享受吧"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"活着真好"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fallthrough</code>语法可以执行满足条件的<code>case</code>的下一个<code>case</code>，是为了兼容C语言中的<code>case</code>设计的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchDemo5</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"a"</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> s == <span class="string">"a"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"a"</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> s == <span class="string">"b"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"b"</span>)</span><br><span class="line">	<span class="keyword">case</span> s == <span class="string">"c"</span>:</span><br><span class="line">		fmt.Println(<span class="string">"c"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<h1 id="goto-跳转到指定标签"><a href="#goto-跳转到指定标签" class="headerlink" title="goto | 跳转到指定标签"></a>goto | 跳转到指定标签</h1><p><code>goto</code>语句通过标签进行代码间的无条件跳转。<code>goto</code>语句可以在快速跳出循环、避免重复退出上有一定的帮助。Go语言中使用<code>goto</code>语句能简化一些代码的实现过程。 例如双层嵌套的<code>for</code>循环要退出时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> breakFlag <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="comment">// 设置退出标签</span></span><br><span class="line">				breakFlag = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 外层for循环判断</span></span><br><span class="line">		<span class="keyword">if</span> breakFlag &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>goto</code>语句能简化代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gotoDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="comment">// 设置退出标签</span></span><br><span class="line">				<span class="keyword">goto</span> breakTag</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">	<span class="comment">// 标签</span></span><br><span class="line">breakTag:</span><br><span class="line">	fmt.Println(<span class="string">"结束for循环"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break | 跳出循环"></a>break | 跳出循环</h1><p><code>break</code>语句可以结束<code>for</code>、<code>switch</code>和<code>select</code>的代码块。</p>
<p><code>break</code>语句还可以在语句后面<strong>添加标签</strong>，表示退出某个标签对应的代码块，标签要求必须定义在对应的<code>for</code>、<code>switch</code>和 <code>select</code>的代码块上。 举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">breakDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">BREAKDEMO1:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">break</span> BREAKDEMO1</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="continue-继续下次循环"><a href="#continue-继续下次循环" class="headerlink" title="continue | 继续下次循环"></a>continue | 继续下次循环</h1><p><code>continue</code>语句可以结束当前循环，开始下一次的循环迭代过程，仅限在<code>for</code>循环内使用。</p>
<p>在 <code>continue</code>语句后<strong>添加标签</strong>时，表示开始标签对应的循环。例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">continueDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">forloop1:</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// forloop2:</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">5</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span> forloop1</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">"%v-%v\n"</span>, i, j)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_06」运算符</title>
    <url>/2020/03/10/go-06/</url>
    <content><![CDATA[<p>Go 语言内置的运算符有：</p>
<ol>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
</ol>
<h1 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">相加</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">相减</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">相乘</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">相除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">求余</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> <code>++</code>（自增）和<code>--</code>（自减）在Go语言中是单独的语句，并不是运算符。</p>
<h1 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td align="center">检查两个值是否相等，如果相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">!=</td>
<td align="center">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td align="center">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td align="center">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td>
</tr>
</tbody></table>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td align="center">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">||</td>
<td align="center">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。</td>
</tr>
<tr>
<td align="center">!</td>
<td align="center">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。</td>
</tr>
</tbody></table>
<h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>位运算符对整数在内存中的二进制位进行操作。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">参与运算的两数各对应的二进位相与。 （两位均为1才为1）</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1）</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移n位就是乘以2的n次方。 “a&lt;&lt;b”是把a的各二进位全部左移b位，高位丢弃，低位补0。</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移n位就是除以2的n次方。 “a&gt;&gt;b”是把a的各二进位全部右移b位。</td>
</tr>
</tbody></table>
<h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">=</td>
<td align="center">简单的赋值运算符，将一个表达式的值赋给一个左值</td>
</tr>
<tr>
<td align="center">+=</td>
<td align="center">相加后再赋值</td>
</tr>
<tr>
<td align="center">-=</td>
<td align="center">相减后再赋值</td>
</tr>
<tr>
<td align="center">*=</td>
<td align="center">相乘后再赋值</td>
</tr>
<tr>
<td align="center">/=</td>
<td align="center">相除后再赋值</td>
</tr>
<tr>
<td align="center">%=</td>
<td align="center">求余后再赋值</td>
</tr>
<tr>
<td align="center">&lt;&lt;=</td>
<td align="center">左移后赋值</td>
</tr>
<tr>
<td align="center">&gt;&gt;=</td>
<td align="center">右移后赋值</td>
</tr>
<tr>
<td align="center">&amp;=</td>
<td align="center">按位与后赋值</td>
</tr>
<tr>
<td align="center">|=</td>
<td align="center">按位或后赋值</td>
</tr>
<tr>
<td align="center">^=</td>
<td align="center">按位异或后赋值</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_05」基本数据类型</title>
    <url>/2020/03/10/go-05/</url>
    <content><![CDATA[<h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><h2 id="普通整形"><a href="#普通整形" class="headerlink" title="普通整形"></a>普通整形</h2><p>整型分为以下两个大类： </p>
<ol>
<li>有符号整形按长度分为：<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code> 。</li>
<li>对应的无符号整型：<code>uint8</code>、<code>uint16</code>、<code>uint32</code>、<code>uint64</code>。</li>
</ol>
<blockquote>
<ul>
<li><code>uint8</code>就是我们熟知的<code>byte</code>型。</li>
<li><code>int16</code>对应C语言中的<code>short</code>型。</li>
<li><code>int64</code>对应C语言中的<code>long</code>型。</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint8</td>
<td align="center">无符号 8位整型 (0 到 255)</td>
</tr>
<tr>
<td align="center">uint16</td>
<td align="center">无符号 16位整型 (0 到 65535)</td>
</tr>
<tr>
<td align="center">uint32</td>
<td align="center">无符号 32位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td align="center">uint64</td>
<td align="center">无符号 64位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td align="center">int8</td>
<td align="center">有符号 8位整型 (-128 到 127)</td>
</tr>
<tr>
<td align="center">int16</td>
<td align="center">有符号 16位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td align="center">int32</td>
<td align="center">有符号 32位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td align="center">int64</td>
<td align="center">有符号 64位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h2 id="特殊整形"><a href="#特殊整形" class="headerlink" title="特殊整形"></a>特殊整形</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">uint</td>
<td align="center">32位操作系统上就是<code>uint32</code>，64位操作系统上就是<code>uint64</code></td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32位操作系统上就是<code>int32</code>，64位操作系统上就是<code>int64</code></td>
</tr>
<tr>
<td align="center">uintptr</td>
<td align="center">无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong> </p>
<ol>
<li>在使用<code>int</code>和 <code>uint</code>类型时，不能假定它是32位或64位的整型，而是考虑<code>int</code>和<code>uint</code>可能在<strong>不同平台上的差异</strong>。</li>
<li>获取对象的长度的内建<code>len()</code>函数返回的长度可以根据不同平台的字节长度进行变化。</li>
<li>实际使用中，切片或 map 的元素数量等都可以用<code>int</code>来表示。</li>
<li>在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用<code>int</code>和 <code>uint</code>。</li>
</ol>
</blockquote>
<h2 id="数字字面量语法（Number-literals-syntax）"><a href="#数字字面量语法（Number-literals-syntax）" class="headerlink" title="数字字面量语法（Number literals syntax）"></a>数字字面量语法（Number literals syntax）</h2><p>Go1.13版本之后引入了数字字面量语法，这样便于开发者以<strong>二进制</strong>、<strong>八进制</strong>或<strong>十六进制</strong>浮点数的格式定义数字，例如：</p>
<ul>
<li>v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。</li>
<li>v := 0o377，代表八进制的 377，相当于十进制的 255。</li>
<li>v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。 </li>
<li>而且还允许我们用 _ 来分隔数字，比如说：v := 123_456 等于 123456。</li>
</ul>
<p>我们可以借助fmt函数来将一个整数以不同进制形式展示。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 十进制</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%d \n"</span>, a)  <span class="comment">// 10</span></span><br><span class="line">	fmt.Printf(<span class="string">"%b \n"</span>, a)  <span class="comment">// 1010  占位符%b表示二进制</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 八进制  以0开头</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">077</span></span><br><span class="line">	fmt.Printf(<span class="string">"%o \n"</span>, b)  <span class="comment">// 77</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 十六进制  以0x开头</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span> = <span class="number">0xff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%x \n"</span>, c)  <span class="comment">// ff</span></span><br><span class="line">	fmt.Printf(<span class="string">"%X \n"</span>, c)  <span class="comment">// FF</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看变量类型</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T \n"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><p>Go语言支持两种浮点型数：<code>float32</code>和<code>float64</code>。这两种浮点型数据格式遵循<code>IEEE 754</code>标准：</p>
<ol>
<li><code>float32</code> 的浮点数的最大范围约为 <code>3.4e38</code>，可以使用常量定义：<code>math.MaxFloat32</code>。</li>
<li><code>float64</code> 的浮点数的最大范围约为 <code>1.8e308</code>，可以使用一个常量定义：<code>math.MaxFloat64</code>。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li><code>float32</code>类型的值不能直接赋值给<code>float64</code>类型的值。</li>
<li>浮点型数默认类型是<code>float64</code>，以保证更加精确。</li>
</ul>
</blockquote>
<p>打印浮点数时，可以使用<code>fmt</code>包配合动词<code>%f</code>，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%f\n"</span>, math.Pi)</span><br><span class="line">        fmt.Printf(<span class="string">"%.2f\n"</span>, math.Pi)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>有<code>complex64</code>和<code>complex128</code>两种类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 <span class="keyword">complex64</span></span><br><span class="line">c1 = <span class="number">1</span> + <span class="number">2i</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">complex128</span></span><br><span class="line">c2 = <span class="number">2</span> + <span class="number">3i</span></span><br><span class="line">fmt.Println(c1)</span><br><span class="line">fmt.Println(c2)</span><br></pre></td></tr></table></figure>

<p>复数有实部和虚部，<code>complex64</code>的实部和虚部为32位，<code>complex128</code>的实部和虚部为64位。</p>
<h1 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h1><p>Go语言中以<code>bool</code>类型进行声明布尔型数据，布尔型数据只有<code>true</code>（真）和<code>false</code>（假）两个值。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>布尔类型变量的默认值为<code>false</code>。</li>
<li>Go 语言中不允许将整型强制转换为布尔型.</li>
<li>布尔型无法参与数值运算，也无法与其他类型进行转换。</li>
</ul>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        b1 := <span class="literal">true</span></span><br><span class="line">        <span class="keyword">var</span> b2 <span class="keyword">bool</span> <span class="comment">// 默认值是false</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T\n"</span>, b1)</span><br><span class="line">        <span class="comment">// %v可以将任何类型的值输出</span></span><br><span class="line">        fmt.Printf(<span class="string">"%T value:%v\n"</span>, b2, b2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型<code>int</code>、<code>bool</code>、<code>float32</code>、<code>float64</code>等一样。 </p>
<p>Go 语言里的字符串的内部实现使用<code>UTF-8</code>编码，<strong>支持中文</strong>。 </p>
<p>字符串的值<strong>只能</strong>用双引号<code>&quot; &quot;</code>引起，可以在Go语言的源码中直接添加<strong>非ASCII码</strong>字符，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">"hello"</span></span><br><span class="line">s2 := <span class="string">"你好"</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串转义符"><a href="#字符串转义符" class="headerlink" title="字符串转义符"></a>字符串转义符</h2><p>Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">转义符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\r</code></td>
<td align="center">回车符（返回行首）</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行符（直接跳到下一行的同列位置）</td>
</tr>
<tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center"><code>\&#39;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center"><code>\&quot;</code></td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
</tbody></table>
<p>举个例子，我们要打印一个Windows平台下的一个文件路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"str := \"c:\\Code\\lesson1\\go.exe\""</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>Go语言中要定义一个多行字符串时，就必须使用反引号<code>`</code>字符：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">`第一行</span></span><br><span class="line"><span class="string">第二行</span></span><br><span class="line"><span class="string">第三行</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">fmt.Println(s1)</span><br></pre></td></tr></table></figure>

<p>反引号间换行将被作为字符串中的换行，但是所有的<strong>转义字符均无效</strong>，文本将会原样输出。</p>
<h2 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">len(str)</td>
<td align="center">求长度</td>
</tr>
<tr>
<td align="center">+或fmt.Sprintf</td>
<td align="center">拼接字符串</td>
</tr>
<tr>
<td align="center">strings.Split</td>
<td align="center">分割</td>
</tr>
<tr>
<td align="center">strings.contains</td>
<td align="center">判断是否包含</td>
</tr>
<tr>
<td align="center">strings.HasPrefix,strings.HasSuffix</td>
<td align="center">前缀/后缀判断</td>
</tr>
<tr>
<td align="center">strings.Index(),strings.LastIndex()</td>
<td align="center">子串出现的位置</td>
</tr>
<tr>
<td align="center">strings.Join(a[]string, sep string)</td>
<td align="center">join操作</td>
</tr>
</tbody></table>
<h1 id="byte和rune类型"><a href="#byte和rune类型" class="headerlink" title="byte和rune类型"></a>byte和rune类型</h1><p>组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 </p>
<p>字符可以是单独的字母、<strong>汉字</strong>或符号，不一定是一个字节。</p>
<p>字符用单引号<code>&#39; &#39;</code>包裹起来，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a := <span class="string">'中'</span></span><br><span class="line"><span class="keyword">var</span> b := <span class="string">'x'</span></span><br></pre></td></tr></table></figure>

<p>Go 语言的字符有以下两种：</p>
<ol>
<li><code>byte</code> 类型，实际上是<code>uint8</code>类型，代表了一个ASCII码字符。</li>
<li><code>rune</code>类型，实际上是<code>int32</code>类型，代表一个 UTF-8字符。</li>
</ol>
<p>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型。</p>
<ul>
<li>Go 使用了特殊的<code>rune</code>类型来处理 Unicode，让基于 Unicode 的文本处理更为方便。</li>
<li>也可以使用<code>byte</code> 型进行默认字符串处理，性能和扩展性都有照顾。</li>
</ul>
<h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">traversalString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"hello沙河"</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123; <span class="comment">//byte</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, s[i], s[i])</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123; <span class="comment">//rune</span></span><br><span class="line">		fmt.Printf(<span class="string">"%v(%c) "</span>, r, r)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) </span><br><span class="line">104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河)</span><br></pre></td></tr></table></figure>

<p>因为UTF8编码下一个中文汉字由3~4个字节组成，所以不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。</p>
<blockquote>
<ul>
<li>字符串底层是一个<code>byte</code>数组，所以可以和<code>[]byte</code>类型相互转换。</li>
<li>字符串是不能修改的，字符串是由<code>byte</code>字节组成，所以<strong>字符串的长度是<code>byte</code>字节的长度</strong>。</li>
<li><code>rune</code>类型用来表示UTF8字符，一个<code>rune</code>字符由一个或多个<code>byte</code>组成。</li>
</ul>
</blockquote>
<h2 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h2><p>要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>，完成后再转换为<code>string</code>。无论哪种转换，都会重新分配内存，并复制字节数组。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeString</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s1 := <span class="string">"big"</span></span><br><span class="line">	<span class="comment">// 强制类型转换</span></span><br><span class="line">	byteS1 := []<span class="keyword">byte</span>(s1)</span><br><span class="line">	byteS1[<span class="number">0</span>] = <span class="string">'p'</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(byteS1))</span><br><span class="line"></span><br><span class="line">	s2 := <span class="string">"白萝卜"</span></span><br><span class="line">	runeS2 := []<span class="keyword">rune</span>(s2)</span><br><span class="line">	runeS2[<span class="number">0</span>] = <span class="string">'红'</span></span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(runeS2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Go语言中<strong>只有强制类型转换</strong>，没有隐式类型转换。该语法只能在两个类型之间<strong>支持</strong>相互转换的时候使用。</p>
<p>强制类型转换的基本语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">T(表达式)</span><br></pre></td></tr></table></figure>

<p>其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.</p>
<p>比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrtDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// math.Sqrt()接收的参数是float64类型，需要强制转换</span></span><br><span class="line">	c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_04」变量与常量</title>
    <url>/2020/03/09/go-04/</url>
    <content><![CDATA[<h1 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编程语言中标识符就是程序员定义的具有特殊意义的词，比如变量名、常量名、函数名等等。</p>
<p>Go语言中标识符由<strong>字母数字和<code>_</code>(下划线）组成，并且只能以字母和<code>_</code>开头</strong>。 举几个例子：<code>abc</code>, <code>_</code>, <code>_123</code>, <code>a123</code>。</p>
<blockquote>
<p>Go语言中推荐使用驼峰式命名。</p>
</blockquote>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。</p>
<p>Go语言中有25个关键字：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>        <span class="keyword">default</span>      <span class="function"><span class="keyword">func</span>         <span class="title">interface</span>    <span class="title">select</span></span></span><br><span class="line"><span class="keyword">case</span>         <span class="keyword">defer</span>        <span class="keyword">go</span>           <span class="keyword">map</span>          <span class="keyword">struct</span></span><br><span class="line"><span class="keyword">chan</span>         <span class="keyword">else</span>         <span class="keyword">goto</span>         <span class="keyword">package</span>      <span class="keyword">switch</span></span><br><span class="line"><span class="keyword">const</span>        <span class="keyword">fallthrough</span>  <span class="keyword">if</span>           <span class="keyword">range</span>        <span class="keyword">type</span></span><br><span class="line"><span class="keyword">continue</span>     <span class="keyword">for</span>          <span class="keyword">import</span>       <span class="keyword">return</span>       <span class="keyword">var</span></span><br></pre></td></tr></table></figure>

<p>此外，Go语言中还有37个保留字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span>  </span><br><span class="line">              <span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line">              <span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line">              <span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line">             <span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line">             <span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure>

<h1 id="Print函数"><a href="#Print函数" class="headerlink" title="Print函数"></a>Print函数</h1><h2 id="Print"><a href="#Print" class="headerlink" title="Print()"></a>Print()</h2><p>在终端中输出要打印的内容。</p>
<h2 id="Printf"><a href="#Printf" class="headerlink" title="Printf()"></a>Printf()</h2><p>在终端中<strong>格式化输出</strong>内容，例如可以使用<code>%s</code>占位符。</p>
<h2 id="Println"><a href="#Println" class="headerlink" title="Println()"></a>Println()</h2><p>打印完内容后在后面添加一个<strong>换行符</strong>。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul>
<li>Go语言中的变量<strong>需要声明后才能使用</strong>，同一作用域内不支持重复声明。 </li>
<li>Go语言的变量<strong>非全局</strong>声明后<strong>必须使用</strong>，全局声明后可以不用。</li>
</ul>
<h3 id="标准声明"><a href="#标准声明" class="headerlink" title="标准声明"></a>标准声明</h3><p>Go语言的变量声明格式为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 变量类型</span><br></pre></td></tr></table></figure>

<p>变量声明以关键字<code>var</code>开头，变量类型放在变量的后面，行尾无需分号。 举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>

<h3 id="批量声明"><a href="#批量声明" class="headerlink" title="批量声明"></a>批量声明</h3><p>每声明一个变量就需要写<code>var</code>关键字会比较繁琐，go语言中还支持批量变量声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">string</span></span><br><span class="line">    b <span class="keyword">int</span></span><br><span class="line">    c <span class="keyword">bool</span></span><br><span class="line">    d <span class="keyword">float32</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值。</p>
<p>例如：</p>
<ul>
<li>整型和浮点型变量的默认值为<code>0</code>。 </li>
<li>字符串变量的默认值为<code>空字符串</code>。</li>
<li>布尔型变量默认为<code>false</code>。</li>
<li>切片、函数、指针变量的默认为<code>nil</code>。</li>
</ul>
<p>当然我们也可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 类型 = 表达式</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"Q1mi"</span></span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>或者一次初始化多个变量：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name, age = <span class="string">"Q1mi"</span>, <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"Q1mi"</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="短变量声明"><a href="#短变量声明" class="headerlink" title="短变量声明"></a>短变量声明</h3><p><strong>在函数内部</strong>，可以使用更简略的 <code>:=</code> 方式声明并初始化变量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 全局变量m</span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">10</span></span><br><span class="line">	m := <span class="number">200</span> <span class="comment">// 此处声明局部变量m</span></span><br><span class="line">	fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>在使用多重赋值时，如果想要忽略某个值，可以使用<code>匿名变量（anonymous variable）</code>。 匿名变量用一个下划线<code>_</code>表示，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">10</span>, <span class="string">"Q1mi"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x, _ := foo()</span><br><span class="line">	_, y := foo()</span><br><span class="line">	fmt.Println(<span class="string">"x="</span>, x)</span><br><span class="line">	fmt.Println(<span class="string">"y="</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。</p>
<p>在<code>Lua</code>等编程语言里，匿名变量也被叫做哑元变量。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>函数外的每个语句都必须以关键字开始，例如<code>var</code>、<code>const</code>、<code>func</code>等。</li>
<li><code>:=</code>不能使用在函数外。</li>
<li><code>_</code>多用于占位，表示忽略值。</li>
</ol>
</blockquote>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h2><p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把<code>var</code>换成了<code>const</code>，常量在定义的时候必须赋值。</p>
<h3 id="标准声明-1"><a href="#标准声明-1" class="headerlink" title="标准声明"></a>标准声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">2.7182</span></span><br></pre></td></tr></table></figure>

<p>声明了<code>pi</code>和<code>e</code>这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。</p>
<h3 id="批量声明-1"><a href="#批量声明-1" class="headerlink" title="批量声明"></a>批量声明</h3><p>多个常量也可以一起声明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    pi = <span class="number">3.1415</span></span><br><span class="line">    e = <span class="number">2.7182</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>const</code>同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    n1 = <span class="number">100</span></span><br><span class="line">    n2</span><br><span class="line">    n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面示例中，常量<code>n1</code>、<code>n2</code>、<code>n3</code>的值都是100。</p>
<h2 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h2><p><code>iota</code>是go语言的<strong>常量</strong>计数器，只能在常量的表达式中使用。</p>
<p><code>iota</code>在<code>const</code><strong>关键字出现时</strong>将被重置为0。<code>const</code>中<strong>每新增一行</strong>常量声明将使<code>iota</code>计数一次（iota可理解为<code>const</code>语句块中的行索引）。 使用iota能简化定义，在定义枚举时很有用。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		n3        <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<hr>
<p>几个常见<code>iota</code>使用示例：</p>
<ol>
<li>使用<code>_</code>跳过某些值：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		_</span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>iota</code>声明中间插队：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2 = <span class="number">100</span>  <span class="comment">//100</span></span><br><span class="line">		n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>定义数量级 </li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		_  = <span class="literal">iota</span></span><br><span class="line">		KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的<code>&lt;&lt;</code>表示左移操作，<code>1&lt;&lt;10</code>表示将1的<strong>二进制</strong>表示向左移10位，也就是由<code>1</code>变成了<code>10000000000</code>，也就是<strong>十进制</strong>的1024。</li>
<li>同理<code>2&lt;&lt;2</code>表示将2的<strong>二进制</strong>表示向左移2位，也就是由<code>10</code>变成了<code>1000</code>，也就是<strong>十进制</strong>的8。</li>
</ul>
<ol start="4">
<li>多个<code>iota</code>定义在一行</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">		c, d                      <span class="comment">//2,3</span></span><br><span class="line">		e, f                      <span class="comment">//3,4</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_03」第一个Go程序</title>
    <url>/2020/03/09/go-03/</url>
    <content><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>现在我们来创建第一个Go项目——<code>hello</code>。在我们的<code>GOPATH</code>下的<code>src</code>目录中创建<code>hello</code>目录。</p>
<p>在该目录中创建一个<code>main.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 声明 main 包，表明当前是一个可执行程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  <span class="comment">// 导入内置 fmt 包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  <span class="comment">// main函数，是程序执行的入口</span></span><br><span class="line">	fmt.Println(<span class="string">"Hello World!"</span>)  <span class="comment">// 在终端打印 Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h1><p><code>go build</code>表示将源代码编译成可执行文件。</p>
<p>在<code>hello</code>目录下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build</span><br></pre></td></tr></table></figure>

<p>或者在其他目录执行以下命令，需要加上项目从<code>GOPATH/src</code>后面开始的路径，编译出的可执行文件就在当前目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build hello</span><br></pre></td></tr></table></figure>

<p>go编译器会去 <code>GOPATH</code>的<code>src</code>目录下查找你要编译的<code>hello</code>项目。</p>
<p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到<code>hello.exe</code>可执行文件。</p>
<p>可在终端直接执行该<code>hello.exe</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\src\hello&gt; hello.exe</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>

<p>我们还可以使用<code>-o</code>参数来<strong>指定</strong>编译后得到的<strong>可执行文件的名字</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go build -o heiheihei.exe</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows下VSCode默认是<code>powershell</code>，建议切换<code>cmd</code>作为默认终端。</p>
</blockquote>
<h1 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h1><p>像执行脚本文件一样执行Go代码。</p>
<h1 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h1><p><code>go install</code>分为两步：</p>
<ol>
<li>先编译得到一个可执行文件；</li>
<li>将可执行文件拷贝到<code>GOPATH/bin</code>。</li>
</ol>
<h1 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h1><p>默认我们<code>go build</code>的可执行文件都是当前操作系统可执行的文件，如果我想在windows下编译一个linux下可执行文件，那需要怎么做呢？</p>
<p>只需要指定目标操作系统的平台和处理器架构即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用了cgo的代码是不支持跨平台编译的</p>
</blockquote>
<p>然后再执行<code>go build</code>命令，得到的就是能够在Linux平台运行的可执行文件了。</p>
<p>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

<p>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure>

<p>Windows下编译Mac平台64位可执行程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_02」配置VSCode</title>
    <url>/2020/03/09/go-02/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><code>VS Code</code>全称<code>Visual Studio Code</code>，是微软公司开源的一款<strong>免费</strong>现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。</p>
<p>虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。</p>
<h1 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h1><p><code>VS Code</code><a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">官方下载地址</a></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="安装中文简体插件"><a href="#安装中文简体插件" class="headerlink" title="安装中文简体插件"></a>安装中文简体插件</h2><ol>
<li>点击左侧菜单栏最后一项<code>管理扩展</code>，在<strong>搜索框</strong>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</li>
<li>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后VS Code就显示中文了。</li>
</ol>
<h2 id="安装Go扩展"><a href="#安装Go扩展" class="headerlink" title="安装Go扩展"></a>安装Go扩展</h2><ol>
<li>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。</li>
<li>在<strong>搜索框</strong>中输入<code>Go</code> ，选中结果列表第一项，点击<code>install</code>安装。</li>
</ol>
<h2 id="安装Go语言开发工具包"><a href="#安装Go语言开发工具包" class="headerlink" title="安装Go语言开发工具包"></a>安装Go语言开发工具包</h2><p>安装Go语言开发工具包后，开发时我们可以获得代码提示、代码自动补全等功能。</p>
<ol>
<li>Windows平台按下<code>Ctrl+Shift+P</code>，Mac平台按<code>Command+Shift+P</code>，这个时候VS Code界面会弹出一个输入框。</li>
<li>在这个输入框中输入<code>&gt;go:install</code>，下面会自动搜索相关命令，选择<code>Go:Install/Update Tools</code>这个命令。</li>
<li>选择<strong>全部工具</strong>，并回车执行该命令。</li>
<li>VS Code此时会下载并安装列出来的16个工具，但是由于国内的网络环境基本上都会出现安装失败，各种<code>FAILED</code>。</li>
<li>我们可以手动从Github上下载工具，执行此步骤前提需要电脑上已经<strong>安装了Git</strong>。<ol>
<li>在自己的<code>GOPATH</code>的<code>src</code>目录下创建<code>golang.org/x</code>目录。</li>
<li>在<code>cmd</code>中<code>cd</code>到<code>GOPATH/src/golang.org/x</code>目录下。</li>
<li>执行<code>git clone https://github.com/golang/tools.git tools</code>命令。</li>
<li>执行<code>git clone https://github.com/golang/lint.git</code>命令。</li>
<li>按下<code>Ctrl+Shift+P</code>再次执行<code>Go:Install/Update Tools</code>命令，在弹出的窗口全选并点击确定，这一次的安装都会<code>SUCCESSED</code>了。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「Go_01」搭建Go语言开发环境</title>
    <url>/2020/03/09/go-01/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://golang.org/dl/" target="_blank" rel="noopener">Go官网下载地址</a></p>
<p><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">Go官方镜像站（推荐）</a></p>
<h1 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h1><ol>
<li>安装Go语言环境；</li>
<li>在<code>cmd</code>窗口中输入<code>go version</code>来测试安装是否成功，输出<code>go version go1.14 windows/amd64</code>代表安装成功。</li>
</ol>
<h1 id="配置GOPATH"><a href="#配置GOPATH" class="headerlink" title="配置GOPATH"></a>配置GOPATH</h1><ul>
<li><code>GOPATH</code>是一个环境变量，用来表明Go语言项目保存的路径。</li>
<li><code>GOPATH</code>路径最好只设置一个，所有的项目代码都放到<code>GOPATH</code>的<code>src</code>路径下。</li>
<li>创建一个文件夹<code>.\Go</code>，创建一个环境变量，变量名为<code>GOPATH</code>，变量内容为这个文件夹的路径。</li>
<li>在 Go 1.8 版本之前，<code>GOPATH</code>环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后会为 <code>GOPATH</code>设置一个默认目录，参见下表，可以把自动创建的<code>GOPATH</code>变量删掉。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">平台</th>
<th align="center">GOPATH默认值</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Windows</td>
<td align="center">%USERPROFILE%/go</td>
<td align="center">C:\Users\dodo\go</td>
</tr>
<tr>
<td align="center">Unix</td>
<td align="center">$HOME/go</td>
<td align="center">/home/dodo/go</td>
</tr>
</tbody></table>
<ul>
<li>在<code>GOPATH</code>目录下新建三个文件夹：<ul>
<li><code>bin</code>：用来存放编译后生成的可执行文件；</li>
<li><code>pkg</code>：用来存放编译后生成的归档文件；</li>
<li><code>src</code>：用来存放源码文件。</li>
</ul>
</li>
<li>把上面创建的<code>.\Go\bin</code>添加到系统的<code>PATH</code>环境变量中。</li>
<li>设置完环境变量后，<strong>重新打开一个</strong><code>cmd</code>，输入<code>go env</code>，可以查看Go语言的环境变量。其中<code>GOPATH</code>是要写代码的位置，<code>GOROOT</code>是安装Go语言环境的位置。</li>
</ul>
<h1 id="Go项目的目录结构"><a href="#Go项目的目录结构" class="headerlink" title="Go项目的目录结构"></a>Go项目的目录结构</h1><p>在进行Go语言开发的时候，我们的代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build</code>、<code>go install</code>或<code>go get</code>等指令后，会将下载的第三方包源代码文件放在<code>$GOPATH/src</code>目录下， 产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p>
<p>如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加<code>$GOPATH/src</code>目录的源代码即可。<code>bin</code> 和 <code>pkg</code> 目录的内容无需版本控制。</p>
<h2 id="适合个人开发者"><a href="#适合个人开发者" class="headerlink" title="适合个人开发者"></a>适合个人开发者</h2><p>我们知道源代码都是存放在<code>GOPATH</code>的<code>src</code>目录下，那我们可以按照下图来组织我们的代码。</p>
<p><img src="001.png" alt="001" title="001"></p>
<h2 id="目前流行的项目结构"><a href="#目前流行的项目结构" class="headerlink" title="目前流行的项目结构"></a>目前流行的项目结构</h2><p>Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用<code>顶级域名</code>来作为包名的前缀，这样就不担心项目名冲突的问题了。</p>
<p>因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。</p>
<p><img src="002.png" alt="002" title="002"></p>
<h2 id="适合企业开发场景"><a href="#适合企业开发场景" class="headerlink" title="适合企业开发场景"></a>适合企业开发场景</h2><p><img src="003.png" alt="003" title="003"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_02」梯度下降</title>
    <url>/2020/03/03/ai-lhyML-02/</url>
    <content><![CDATA[<h1 id="复习：梯度下降法"><a href="#复习：梯度下降法" class="headerlink" title="复习：梯度下降法"></a>复习：梯度下降法</h1><p>在之前的第三步中，要解一个优化问题：<br>$$<br>\theta^* = \arg \min_\theta L(\theta)<br>$$</p>
<ul>
<li>$L$：损失函数.</li>
<li>$\theta$：参数.</li>
</ul>
<p>假设$\theta$包含两个变量${\theta_1, \theta_2}$.</p>
<ol>
<li>随机地选择一个起始的$\theta$</li>
</ol>
<p>$$<br>\theta^0 = \left[<br>\begin{matrix}<br>\theta_1^0 \\<br>\theta_2^0<br>\end{matrix}<br>\right]<br>$$</p>
<ol start="2">
<li>计算下一个点的坐标</li>
</ol>
<p>$$<br>\left[<br>\begin{matrix}<br>\theta_1^1 \\<br>\theta_2^1<br>\end{matrix}<br>\right] = \left[<br>\begin{matrix}<br>\theta_1^0 \\<br>\theta_2^0<br>\end{matrix}<br>\right] - \eta \left[<br>\begin{matrix}<br>\frac{\partial L(\theta_1^0)}{\partial \theta_1} \\<br>\frac{\partial L(\theta_2^0)}{\partial \theta_2}<br>\end{matrix}<br>\right]<br>$$</p>
<ol start="3">
<li>反复进行.</li>
</ol>
<blockquote>
<p>梯度表示为<br>$$<br>\nabla L(\theta) = \left[<br>\begin{matrix}<br>\frac{\partial C(\theta_1)}{\partial \theta_1} \\<br>\frac{\partial C(\theta_2)}{\partial \theta_2}<br>\end{matrix}<br>\right]<br>$$</p>
</blockquote>
<p>那么点的更新过程就可以写成：</p>
<p>$$<br>\theta^1 = \theta^0 - \eta \nabla L(\theta^0)<br>$$</p>
<p>$$<br>\theta^2 = \theta^1 - \eta \nabla L(\theta^1)<br>$$</p>
<h1 id="提示一：小心调整步长"><a href="#提示一：小心调整步长" class="headerlink" title="提示一：小心调整步长"></a>提示一：小心调整步长</h1><p>如果步长过短，可能会需要很长时间才能收敛；如果步长过长，可能无法收敛到最优点.</p>
<p>对于多维的目标函数，可能无法可视化迭代的过程，但是可以可视化<strong>不同的步长下Loss值和迭代次数的关系图</strong>.</p>
<h2 id="自适应调整步长"><a href="#自适应调整步长" class="headerlink" title="自适应调整步长"></a>自适应调整步长</h2><ul>
<li>一种常用的做法：<strong>每隔几次迭代就减小步长</strong>.<ul>
<li>最开始的时候，我们距离最优点很远，所以我们可以使用很大的步长.</li>
<li>经过若干次迭代后，我们距离最优点很近了，所以我们要减小步长.</li>
<li>例如：$\frac{1}{t}$衰减，$\eta^t = \frac{\eta}{\sqrt{t+1}}$，其中$t$代表迭代次数.</li>
</ul>
</li>
<li>步长的选择是不可能一劳永逸的.<ul>
<li>最好的做法是，<strong>每个参数选择不同的步长</strong>. </li>
</ul>
</li>
</ul>
<h2 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h2><p>将每一个参数的步长都除以它之前导数的均方根.</p>
<p>批次梯度下降（Vanilla Gradient descent）的做法：<br>$$<br>w^t - \eta^t g^t \rightarrow w^{t+1}<br>$$<br>改进版算法（Adagrad）的做法：<br>$$<br>w^t - \frac{\eta^t}{\sigma^t} g^t \rightarrow w^{t+1}<br>$$</p>
<ul>
<li>$w$：是其中一个参数，因为改进的算法要针对每个参数选择不同的步长.</li>
<li>$\sigma^t$：参数$w$的前一个导数的均方根.</li>
<li>$\eta^t = \frac{\eta}{\sqrt{t+1}}$.</li>
<li>$g^t = \frac{\partial C(\theta^t)}{\partial w}$.</li>
</ul>
<p>这样以来，每次参数的更新都是依赖于每个参数的不同梯度.</p>
<p>例子：<br>$$<br>w^1 \leftarrow w^0 - \frac{\eta^0}{\sigma^0} g^0 , \sigma^0 = \sqrt{(g^0)^2}<br>$$</p>
<p>$$<br>w^2 \leftarrow w^1 - \frac{\eta^1}{\sigma^1} g^1 , \sigma^1 = \sqrt{\frac{1}{2}[(g^0)^2+(g^1)^2]}<br>$$</p>
<p>$$<br>w^3 \leftarrow w^2 - \frac{\eta^2}{\sigma^2} g^2 , \sigma^2 = \sqrt{\frac{1}{3}[(g^0)^2+(g^1)^2+(g^2)^2]}<br>$$</p>
<p>$$<br>\dots \dots<br>$$</p>
<p>$$<br>w^{t+1} \leftarrow w^t - \frac{\eta^t}{\sigma^t} g^t , \sigma^t = \sqrt{\frac{1}{t+1} \sum_{i=0}^{t}(g^i)^2}<br>$$</p>
<p>将$\eta^t$和$\sigma^t$的表达式代入到式中，上下同时消去$\frac{1}{\sqrt{t+1}}$得：<br>$$<br>w^{t+1} \leftarrow w^t - \frac{\eta}{\sqrt{\sum_{i=0}^{t}(g^i)^2}} g^t<br>$$</p>
<h2 id="矛盾"><a href="#矛盾" class="headerlink" title="矛盾"></a>矛盾</h2><p>在上面得到的式子里，梯度$g^t$越大，他每次迭代的变化越大，但是分母$\sqrt{\sum_{i=0}^{t}(g^i)^2}$就会越小.</p>
<h3 id="直观的解释"><a href="#直观的解释" class="headerlink" title="直观的解释"></a>直观的解释</h3><p>例如：</p>
<table>
<thead>
<tr>
<th align="center">$g^0$</th>
<th align="center">$g^1$</th>
<th align="center">$g^2$</th>
<th align="center">$g^3$</th>
<th align="center">$g^4$</th>
<th align="center">$\dots$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0.001</td>
<td align="center">0.001</td>
<td align="center">0.003</td>
<td align="center">0.002</td>
<td align="center">0.1</td>
<td align="center">$\dots$</td>
</tr>
</tbody></table>
<p>$g^4$的反差特别大.</p>
<table>
<thead>
<tr>
<th align="center">$g^0$</th>
<th align="center">$g^1$</th>
<th align="center">$g^2$</th>
<th align="center">$g^3$</th>
<th align="center">$g^4$</th>
<th align="center">$\dots$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10.8</td>
<td align="center">20.9</td>
<td align="center">31.7</td>
<td align="center">12.1</td>
<td align="center">0.1</td>
<td align="center">$\dots$</td>
</tr>
</tbody></table>
<p>$g^4$的反差特别小.</p>
<p>分母$\sqrt{\sum_{i=0}^{t}(g^i)^2}$就表示了造成反差的效果.</p>
<h1 id="提示二：随机梯度下降法"><a href="#提示二：随机梯度下降法" class="headerlink" title="提示二：随机梯度下降法"></a>提示二：随机梯度下降法</h1><p>原来的梯度下降方法：</p>
<ul>
<li>损失函数的计算：</li>
</ul>
<p>$$<br>L = \sum_{n} \left(\hat{y}^n - \left(b + \sum w_i x_i^n\right)\right)^2<br>$$</p>
<ul>
<li>点的更新：</li>
</ul>
<p>$$<br>\theta^i = \theta^{i-1} - \eta \nabla L(\theta^{i-1})<br>$$</p>
<p>而随机梯度下降法（Stochastic Gradient Descent）：</p>
<ul>
<li>选择一个样本$x^n$.</li>
<li>只计算选择的样本$x^n$的损失函数：</li>
</ul>
<p>$$<br>L^n = \left( \hat{y}^n - \left( b + \sum w_i x_i^n \right) \right)^2<br>$$</p>
<ul>
<li>根据样本$x^n$的损失函数来更新点：</li>
</ul>
<p>$$<br>\theta^i = \theta^{i-1} - \eta \nabla L^n(\theta^{i-1})<br>$$</p>
<p>这样，在原来的梯度下降法看了全部样本之前，就可以看一个样本走一步，最后得到解.</p>
<h1 id="提示三：特征放缩"><a href="#提示三：特征放缩" class="headerlink" title="提示三：特征放缩"></a>提示三：特征放缩</h1><p>例如，函数<br>$$<br>y = b + w_1 x_1 + w_2 x_2<br>$$<br>当中，$x_1$和$x_2$的尺度不同，那么就要进行特征放缩，让特征拥有相同的尺度.</p>
<hr>
<p>一种常见的特征放缩的方法：</p>
<p>假设有$R$个<strong>样本</strong>，每个样本中都有一组<strong>特征</strong>：</p>
<ul>
<li>$x^1={x_1^1, x_2^1, x_3^1, \dots , x_n^1}$.</li>
<li>$x^2={x_1^2, x_2^2, x_3^2, \dots , x_n^2}$.</li>
<li>$x^3={x_1^3, x_2^3, x_3^3, \dots , x_n^3}$.</li>
<li>$\dots \dots$</li>
<li>$x^r={x_1^r, x_2^r, x_3^r, \dots , x_n^r}$.</li>
<li>$\dots \dots $</li>
<li>$x^R={x_1^R, x_2^R, x_3^R, \dots , x_n^R}$.</li>
</ul>
<p>对于每一个维度$i$的特征，计算：</p>
<ol>
<li>均值：</li>
</ol>
<p>$$<br>m_i = \frac{1}{R} \sum^{R}_{j=1} x_i^j<br>$$</p>
<ol start="2">
<li>标准差：</li>
</ol>
<p>$$<br>\sigma_i = \frac{1}{R}\sum_{j=1}^{R} \left( x_i^j - m_i \right)^2<br>$$</p>
<ol start="3">
<li>计算尺度变换后的特征：</li>
</ol>
<p>$$<br>x_i^r = \dfrac{x_i^r - m_i}{\sigma_i}<br>$$</p>
<p>这样得到的新的特征<strong>均值为0，方差为1</strong>.</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「AI_03」回归</title>
    <url>/2020/03/02/ai-lhyML-01/</url>
    <content><![CDATA[<h1 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h1><ul>
<li>股票预测系统：利用以往的数据来判断未来的股票.</li>
<li>无人驾驶：利用一些传感器数据来判断方向盘角度.</li>
<li>推荐系统：输入使用者A和商品B，输出使用者购买可能性.</li>
</ul>
<h1 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h1><p>评估宝可梦的<strong>CP值（战斗力）</strong>，从而判断是否进化宝可梦.</p>
<p>输入是某只宝可梦：</p>
<ul>
<li>$x$代表宝可梦.</li>
<li>$x_{cp}$代表宝可梦的<strong>CP值</strong>.</li>
<li>$x_s$代表宝可梦的<strong>物种</strong>.</li>
<li>$x_{hp}$代表宝可梦的<strong>生命值</strong>.</li>
<li>$x_w$代表宝可梦的<strong>重量</strong>.</li>
<li>$x_h$代表宝可梦的<strong>高度</strong>.</li>
<li>$y$代表<strong>进化后的CP值</strong>.</li>
</ul>
<h2 id="第一步：模型"><a href="#第一步：模型" class="headerlink" title="第一步：模型"></a>第一步：模型</h2><p>例如选择：<br>$$<br>y = b + w \cdot x_{cp}<br>$$</p>
<blockquote>
<p>线性模型：<br>$$<br>y = b + \sum w_i x_i<br>$$<br>其中：</p>
<ul>
<li>$x_i$是输入的不同属性，称为<strong>特征</strong>.</li>
<li>$w_i$是每个特征对应的<strong>权重</strong>.</li>
<li>$b$称为<strong>偏置</strong>.</li>
</ul>
</blockquote>
<h2 id="第二步：模型性能"><a href="#第二步：模型性能" class="headerlink" title="第二步：模型性能"></a>第二步：模型性能</h2><p>接下来要收集<strong>训练数据</strong>才能找到模型的函数.</p>
<p>我们收集的是模型的输入和输出，因为是一个回归的模型，所以<strong>输出是一个数值</strong>.</p>
<p>举例来说（用<strong>上标</strong>表示<strong>完整的对象的编号</strong>，用<strong>下标</strong>表示对象的<strong>成分</strong>）：</p>
<ul>
<li>杰尼龟$x^1$进化到卡咪龟$\hat{y}^1=979$.</li>
<li>伊布$x^2$进化到雷精灵$\hat{y}^2=1420$.</li>
</ul>
<p>由此，收集了10只宝可梦的数据：<br>$$<br>(x^1,\hat{y}^1), (x^2,\hat{y}^2), \dots ,(x^{10},\hat{y}^{10})<br>$$<br>可以绘制出来一张$x_{cp}-\hat{y}$的散点图。</p>
<blockquote>
<p>接下来要判断不同函数的好坏，这里需要定义一个新的函数<strong>损失函数$L$</strong>，这是一个函数的函数：</p>
<ul>
<li>输入：一个函数.</li>
<li>输出：这个函数有<strong>多不好</strong>.</li>
</ul>
<p>$$<br>L(f) = L(w,b)<br>$$</p>
<p>因为$f$是由$w, b$决定的，所以我们可以说损失函数是用来衡量一组参数的好坏.</p>
<p>实际上可以选择不同的损失函数的形式，这里就将数据带入到$y = b + w \cdot x_{cp}$中，然后计算差的平方和，即：<br>$$<br>L(f) = L(w,b) = \sum_{n=1}^{10} (\hat{y}^n - (b + w \cdot x_{cp}^n))^2<br>$$</p>
</blockquote>
<h2 id="第三步：最优方程"><a href="#第三步：最优方程" class="headerlink" title="第三步：最优方程"></a>第三步：最优方程</h2><blockquote>
<p>根据损失函数来挑选最好的方程<br>$$<br>f^* = \arg \min_f L(f)<br>$$<br>或<br>$$<br>\begin{align}<br>w^* , b^* &amp; = \arg \min_{w,b} L(w, b) \\<br>&amp; = \arg \min_{w,b} \sum_{n=1}^{10} (\hat{y}^n - (b + w \cdot x_{cp}^n))^2<br>\end{align}<br>$$<br>从中选择能够使得损失函数最好的$w,b$参数.</p>
</blockquote>
<h2 id="第三步：梯度下降法"><a href="#第三步：梯度下降法" class="headerlink" title="第三步：梯度下降法"></a>第三步：梯度下降法</h2><p>这里使用<strong>梯度下降法（Gradient Descent）</strong>来处理优化问题.</p>
<p>先假设一个比较简单的损失函数$L(w)$，只包含一个参数$w$.不一定是前面定义的损失函数，可以是任何<strong>可微分</strong>的函数.</p>
<p>现在的问题就是：<br>$$<br>w^* = \arg \min_w L(w)<br>$$<br>梯度下降法的做法：</p>
<ol>
<li><strong>随机</strong>选取一个初始的点$w^0$.</li>
<li>计算$\frac{dL}{dw}|_{w=w^0}$，如果算出来斜率是负值，就应该增大$w$；如果计算出来斜率是正值，就应该减小$w$.</li>
<li>参数更新，$w^0 - \eta \frac{dL}{dw}|_{w=w^0} \rightarrow w^1$，其中$\eta$称为学习率.</li>
<li>依次迭代2和3步.</li>
</ol>
<blockquote>
<p>推广到两个参数，步骤是一样的：</p>
<ol>
<li><strong>随机</strong>选取一个初始的点$w^0,b^0$.</li>
<li>计算$ \frac{\partial L}{\partial w}|_{w=w^0,b=b^0},\frac{\partial L}{\partial b}|_{w=w^0,b=b^0}$.</li>
<li>参数更新$ w^0 - \eta \frac{\partial L}{\partial w}|_{w=w^0,b=b^0} \rightarrow w^1,b^0 - \eta \frac{\partial L}{\partial b}|_{w=w^0,b=b^0} \rightarrow b^1$.</li>
<li>依次迭代2和3步.</li>
</ol>
<p><strong>注意</strong>：线性回归中，损失函数是<strong>凸函数</strong>，所以局部最优解就是全局最优解.</p>
</blockquote>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>求误差之和来评估模型的性能：<br>$$<br>e_{avg} = \sum_{n=1}^{10} e^n<br>$$<br>原来数据的$e_{avg} = 31.9$，又捕捉了10只新的宝可梦，计算$e_{avg} = 35.0$.</p>
<h2 id="选择其他模型"><a href="#选择其他模型" class="headerlink" title="选择其他模型"></a>选择其他模型</h2><p>选择一个更加复杂的模型，带有<strong>二次项</strong>：<br>$$<br>y = b + w_1 \cdot x_{cp} + w_2 \cdot (x_{cp})^2<br>$$<br>甚至带有<strong>三次项</strong>：<br>$$<br>y = b + w_1 \cdot x_{cp} + w_2 \cdot (x_{cp})^2 + w_3 \cdot (x_{cp})^3<br>$$<br><strong>四次项</strong>：<br>$$<br>y = b + w_1 \cdot x_{cp} + w_2 \cdot (x_{cp})^2 + w_3 \cdot (x_{cp})^3 + w_4 \cdot (x_{cp})^4<br>$$<br>出现了<strong>过拟合</strong>.</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><blockquote>
<p>前面的损失函数只考虑了预测值和实际值之间的<strong>误差</strong>，正则化就是给损失函数加上额外的项.<br>$$<br>y = b + \sum w_i x_i<br>$$</p>
<p>$$<br>L = \sum_{n} (\hat{y}^n - (b + w \cdot x_{cp}^n))^2 + \lambda \sum (w_i)^2<br>$$</p>
</blockquote>
<p>我们期待找到的函数中$w_i$参数越小越好，因为$w_i$小的函数是非常<strong>平滑</strong>的，也就是函数对于输入变化不敏感，输入的变化对输出的变化影响很小，这样可以降低噪声干扰.</p>
<p>$\lambda$的数值越大，我们对$w_i$<strong>参数本身</strong>越关注，而减少了对误差的关注.我们可以手动调整$\lambda$的数值.</p>
<p>要注意的是，因为偏置$b$并不会影响函数的平滑程度，而只是让函数上下移动，所以正则化不用考虑偏置项.</p>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>李宏毅</tag>
        <tag>机器学习</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>「线性代数_01」矩阵及其应用</title>
    <url>/2017/02/28/linearAlgebra-01/</url>
    <content><![CDATA[<h1 id="矩阵的概念"><a href="#矩阵的概念" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h1><h2 id="矩阵的概念-1"><a href="#矩阵的概念-1" class="headerlink" title="矩阵的概念"></a>矩阵的概念</h2><blockquote>
<p><strong>定义：</strong></p>
<p>由$ m \times n $个数$ a_{ij} ( i=1,2,…,m;j=1,2,…,n ) $排成一个$ m $行$ n $列的矩形数表<br>$$<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1} &amp; a_{m2} &amp; \dots &amp; a_{mn}<br>\end{pmatrix}<br>$$</p>
<p>或</p>
<p>$$<br>\begin{bmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1} &amp; a_{m2} &amp; \dots &amp; a_{mn}<br>\end{bmatrix}<br>$$</p>
<p>称为$ m \times n $矩阵或$ m $行$ n $列矩阵，简称<strong>矩阵</strong>.横排称为矩阵的<strong>行</strong>，纵排称为矩阵的<strong>列</strong>，$ a_{ij} ( i=1,2,…,m;j=1,2,…,n ) $称为矩阵的第$ i $行第$ j $列<strong>元</strong>或$ (i,j) $<strong>元</strong>.$ m \times n $矩阵通常用大写字母如$ \pmb{A},\pmb{B},… $表示，有时也记作$ \pmb{A} = ( a_{ij} )_{m \times n} $.</p>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>实矩阵</strong>：元都是实数的矩阵.</li>
<li><strong>复矩阵</strong>：元都是复数的矩阵.</li>
<li><strong>零矩阵</strong>：元都是$ 0 $的矩阵，记为$ \pmb{O} $.</li>
<li><strong>列矩阵</strong>：只有一列的矩阵，也称为列向量.</li>
</ul>
<p>$$<br>\pmb{A} =<br>\begin{pmatrix}<br>a_1 \\<br>a_2 \\<br>\vdots \\<br>a_m<br>\end{pmatrix}<br>$$</p>
<ul>
<li><strong>行矩阵</strong>：只有一行的矩阵，也称为行向量.</li>
</ul>
<p>$$<br>\pmb{B} =<br>\begin{pmatrix}<br>b_1 &amp; b_2 &amp; \dots &amp;    b_n<br>\end{pmatrix}<br>$$</p>
<ul>
<li><p>行向量和列向量也可以用小写字母$ \pmb{a}, \pmb{b},…; \pmb{\alpha} , \pmb{\beta} , … $表示.</p>
</li>
<li><p>若$ m=n $，即矩阵的行数与列数相同时，称矩阵为<strong>$ n $阶矩阵</strong>或<strong>$ n $阶方阵</strong>.在$ n $阶矩阵<strong>$ A $</strong>中，从左上角到右下角的对角线称为$ \pmb{A} $的<strong>主对角线</strong>，主对角线上的元$ a_{ii} $称为$ n $阶矩阵$ \pmb{A} $的主对角线元；从右上角到左下角的对角线称为$ \pmb{A} $的<strong>次对角线</strong>.</p>
</li>
</ul>
</blockquote>
<h2 id="几种特殊矩阵"><a href="#几种特殊矩阵" class="headerlink" title="几种特殊矩阵"></a>几种特殊矩阵</h2><ul>
<li><p><strong>上三角（形）矩阵</strong>：主对角线以下的元全为$ 0 $的$ n $阶方阵.<br>$$<br>\pmb{A} =<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>0 &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>0 &amp; 0 &amp; \dots &amp; a_{nn}<br>\end{pmatrix}<br>$$</p>
</li>
<li><p><strong>下三角（形）矩阵</strong>：主对角线以上的元全为$ 0 $的$ n $阶方阵.</p>
</li>
</ul>
<p>$$<br>\pmb{B} =<br>\begin{pmatrix}<br>b_{11} &amp; 0 &amp; \dots &amp; 0 \\<br>b_{21} &amp; b_{22} &amp; \dots &amp; 0 \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>b_{n1} &amp; b_{n2} &amp; \dots &amp; b_{nn}<br>\end{pmatrix}<br>$$</p>
<ul>
<li><p><strong>三角形矩阵</strong>：上三角形矩阵和下三角形矩阵统称为三角形矩阵.</p>
</li>
<li><p><strong>对角矩阵（diagonal matrix）</strong>：如果$ n $阶方阵的主对角线以外的元全为$ 0 $，则称为对角矩阵，记作$ \pmb{\Lambda} $或$ diag(a_{11} , a_{22} , \dots , a_{nn}) $.<br>$$<br>\pmb{\Lambda} =<br>\begin{pmatrix}<br>a_{11} &amp; &amp; &amp; \\<br>&amp; a_{22} &amp; &amp; \\<br>&amp;  &amp; \ddots &amp; \\<br>&amp;  &amp;  &amp; a_{nn}<br>\end{pmatrix}<br>$$</p>
</li>
</ul>
<blockquote>
<p>对角矩阵对角线上可以有零元.</p>
</blockquote>
<ul>
<li><p><strong>单位矩阵</strong>：主对角线上的元全为$ 1 $的$ n $阶对角矩阵称为$ n $阶单位矩阵，记作$ E_n $，$ I_n $或$ E $，$ I $.<br>$$<br>E = I =<br>\begin{pmatrix}<br>1 &amp; &amp; &amp; \\<br>&amp; 1 &amp; &amp; \\<br>&amp;  &amp; \ddots &amp; \\<br>&amp;  &amp;  &amp; 1<br>\end{pmatrix}<br>$$</p>
</li>
<li><p><strong>同型矩阵</strong>：两个行数与列数相等的矩阵.</p>
</li>
<li><p><strong>相等矩阵</strong>：设 $ \pmb{A}=(a_{ij})_{m\times n} $与$ \pmb{B}= (a_{ij})_{m\times n} $是同型矩阵且对应元相等，则称$ \pmb{A} $与$ \pmb{B} $相等，记作$ \pmb{A} = \pmb{B} $.即</p>
</li>
</ul>
<p>$$<br>\pmb{A} = \pmb{B} \Leftrightarrow a_{ij} = b_{ij},i=1,2,…,m;j=1,2,…,n.<br>$$</p>
<ul>
<li><strong>系数矩阵</strong>：在实际问题中，常常会遇到一些变量要用另外一些变量线性表示.设一组变量$ y_1 , y_2 ,…, y_m $用另一组变量$ x_1 , x_2 ,…, x_n $表示为<br>$$<br>\left \lbrace<br>\begin{aligned}<br>y_1 &amp; = a_{11}x_1+a_{12}x_2+…+a_{1n}x_n \\<br>y_2 &amp; = a_{21}x_1+a_{22}x_2+…+a_{2n}x_n \\<br>&amp; \dots \dots \dots \dots \\<br>y_m &amp; = a_{m1}x_1+a_{m2}x_2+…+a_{mn}x_n<br>\end{aligned}<br>\right.<br>$$</li>
</ul>
<p>称此关系式为从变量$ x_1 , x_2 ,…, x_n $到变量$ y_1 , y_2 ,…, y_m $的线性变换.</p>
<p>这个线性变换中的系数组成的矩阵$ {A} $称为此线性变换的系数矩阵.</p>
<p>$$<br>\pmb{A} =<br>\begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \dots &amp; a_{1n} \\<br>a_{21} &amp; a_{22} &amp; \dots &amp; a_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1} &amp; a_{m1} &amp; \dots &amp; a_{mn}<br>\end{pmatrix}<br>$$</p>
<h1 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h1><h2 id="矩阵的加法与数乘"><a href="#矩阵的加法与数乘" class="headerlink" title="矩阵的加法与数乘"></a>矩阵的加法与数乘</h2><blockquote>
<p><strong>定义</strong>：</p>
<p>设有两个同型的$ m\times n $矩阵$ \pmb{A}=(a_{ij}),\pmb{B}=(b_{ij}) $. 矩阵$ \pmb{A} $与$ \pmb{B} $的和记作$ \pmb{A}+\pmb{B} $，规定为</p>
<p>$$<br>\pmb{A}+\pmb{B} =<br>\begin{pmatrix}<br>a_{11}+b_{11} &amp; a_{12}+b_{12} &amp; \dots &amp; a_{1n}+b_{1n} \\<br>a_{21}+b_{21} &amp; a_{22}+b_{22} &amp; \dots &amp; a_{2n}+b_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>a_{m1}+b_{m1} &amp; a_{m1}+b_{m1} &amp; \dots &amp; a_{mn}+b_{mn}<br>\end{pmatrix}<br>$$</p>
</blockquote>
<hr>
<blockquote>
<p><strong>定义</strong>：</p>
<p>数$ k $与矩阵$ \pmb{A} $的乘积，简称数乘，记作$ k\pmb{A} $或$ \pmb{A}k $,规定为</p>
<p>$$<br>k\pmb{A} = \pmb{A}k =<br>\begin{pmatrix}<br>ka_{11} &amp; ka_{12} &amp; \dots &amp; ka_{1n} \\<br>ka_{21} &amp; ka_{22} &amp; \dots &amp; ka_{2n} \\<br>\vdots &amp; \vdots &amp; &amp; \vdots \\<br>ka_{m1} &amp; ka_{m1} &amp; \dots &amp; ka_{mn}<br>\end{pmatrix}<br>$$</p>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>矩阵的加法与数乘统称为<strong>矩阵的线性运算</strong>.</li>
<li><strong>负矩阵</strong>：对于矩阵$ \pmb{A}= (a_{ij}) $, 称矩阵$ (-a_{ij}) $为$ \pmb{A} $的负矩阵，记作$ -\pmb{A} $.</li>
<li><strong>矩阵的减法</strong>：由负矩阵可以定义矩阵$ {A} $与$ {B} $的减法为$ \pmb{A}-\pmb{B} = \pmb{A}+(-\pmb{B}) $，即两个同型矩阵相减，归结为它们的对应元相减.</li>
<li>$ \pmb{A} = \pmb{B} \Leftrightarrow \pmb{A}-\pmb{B}=\pmb{O} $.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>性质</strong>：</p>
<p>矩阵的线性运算满足下列运算规律（设$ \pmb{A} , \pmb{B} , \pmb{C} $都是$ m\times n $矩阵，$ k $ 与$ l $ 为数）：</p>
<ol>
<li>$ \pmb{A}+\pmb{B}=\pmb{B}+\pmb{A} $.</li>
<li>$ (\pmb{A}+\pmb{B})+\pmb{C} = \pmb{A}+(\pmb{B}+\pmb{C}) $.</li>
<li>$ \pmb{A}+\pmb{O}=\pmb{A} $.</li>
<li>$ \pmb{A}+(-\pmb{A})=\pmb{O} $.</li>
<li>$ 1 \cdot \pmb{A} = \pmb{A} $.</li>
<li>$ (kl)\pmb{A}=k(l\pmb{A}) $.</li>
<li>$ (k+l)\pmb{A}=k\pmb{A}+l\pmb{A} $.</li>
<li>$ k(\pmb{A}+\pmb{B})=k\pmb{A}+k\pmb{B} $.</li>
</ol>
</blockquote>
<h2 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h2><blockquote>
<p><strong>定义</strong>：</p>
<p>设$ \pmb{A}=(a_{ij}) $是一个$ m\times s $矩阵，$ \pmb{B}=(b_{ij}) $是一个$ s\times n $矩阵，规定矩阵 $ \pmb{A} $与矩阵$ \pmb{B} $的乘积是$ m\times n $矩阵$ \pmb{C}=(c_{ij}) $，记为$ \pmb{C}=\pmb{AB} $,其中</p>
<p>$$<br>c_{ij} = a_{i1}b_{1j}+a_{i2}b_{2j}+…+a_{is}b_{sj}=\sum_{k=1}^{s} a_{ik}b_{kj}.(i=1,2,…,m;j=1,2,…,n)<br>$$</p>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>矩阵乘法不满足交换律，即在一般条件下，$ \pmb{AB} \neq \pmb{BA} $.        </li>
<li>两个非零矩阵之积可能是零矩阵.</li>
<li>若$ \pmb{A}\neq\pmb{O} $，$\pmb{AB}=\pmb{AC} $不能推出$ \pmb{B}=\pmb{C} $.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>性质</strong>：</p>
<p>矩阵的乘法满足下面的运算规律：</p>
<ul>
<li>$ (\pmb{AB})\pmb{C}=\pmb{A}(\pmb{BC}) $.</li>
<li>$ \pmb{A}(\pmb{B}+\pmb{C})=\pmb{AB}+\pmb{AC} , (\pmb{B}+\pmb{C})\pmb{A}=\pmb{BA}+\pmb{CA} $.</li>
<li>$ \lambda(\pmb{AB})=(\lambda\pmb{A})\pmb{B}=\pmb{A}(\lambda\pmb{B}) $，其中$ \lambda $是数.</li>
<li>$  \pmb{E}_m\pmb{A}_{m\times n} = \pmb{A}_{m\times n}\pmb{E}_n = \pmb{A}_{m\times n} $.</li>
</ul>
</blockquote>
<h2 id="方阵的幂与多项式"><a href="#方阵的幂与多项式" class="headerlink" title="方阵的幂与多项式"></a>方阵的幂与多项式</h2><p>设$ \pmb{A} $为$ n $阶方阵，$ k $为正整数，$ k $个$ \pmb{A} $的连乘积称为$ \pmb{A} $的$ k $次幂，记作$ \pmb{A}^k $.即</p>
<p>$$<br>\pmb{A}^k=\overbrace{\pmb{A}\pmb{A} … \pmb{A}}^{k}<br>$$</p>
<blockquote>
<p><strong>注意</strong>：$ \pmb{A}^0 = \pmb{E} $.</p>
</blockquote>
<hr>
<blockquote>
<p><strong>性质</strong>：</p>
<p>方阵的幂满足下面运算规律（$ \pmb{A} $为方阵，$ k,l $为非负整数）：</p>
<ul>
<li>$ \pmb{A}^k\pmb{A}^l=\pmb{A}^{k+l} $.</li>
<li>$ (\pmb{A}^k)^l=\pmb{A}^{kl} $.</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>注意</strong>：由于矩阵乘法不满足交换律，一般地，$ (\pmb{AB})^k\neq \pmb{A}^k\pmb{B}^k $.</p>
</blockquote>
<h2 id="矩阵的转置"><a href="#矩阵的转置" class="headerlink" title="矩阵的转置"></a>矩阵的转置</h2><h2 id="共轭矩阵"><a href="#共轭矩阵" class="headerlink" title="共轭矩阵"></a>共轭矩阵</h2><h2 id="可逆矩阵"><a href="#可逆矩阵" class="headerlink" title="可逆矩阵"></a>可逆矩阵</h2><h1 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h1><h1 id="矩阵的初等变换"><a href="#矩阵的初等变换" class="headerlink" title="矩阵的初等变换"></a>矩阵的初等变换</h1><h2 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h2><h2 id="初等变换"><a href="#初等变换" class="headerlink" title="初等变换"></a>初等变换</h2><h1 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h1>]]></content>
      <categories>
        <category>线性代数</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「Markdown_03」使用Flowchart绘图</title>
    <url>/2016/09/10/markdown-03/</url>
    <content><![CDATA[<h1 id="安装Flowchart插件"><a href="#安装Flowchart插件" class="headerlink" title="安装Flowchart插件"></a>安装Flowchart插件</h1><ol>
<li><p>在<strong>Git Bash</strong>中输入<code>npm install --save hexo-filter-flowchart</code>。</p>
</li>
<li><p>如果没有特殊要求的话，不需要进行<code>.yml</code>文件的配置。</p>
</li>
<li><p>到这里，我们就可以通过<strong>添加代码块</strong>的方式来绘制图形了，这里要注意，添加的代码块要注明代码类型为<code>flow</code>。</p>
</li>
</ol>
<h1 id="绘制流程图"><a href="#绘制流程图" class="headerlink" title="绘制流程图"></a>绘制流程图</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>通用语法示意如下：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tag=&gt;type: content:&gt;url</span><br><span class="line">...</span><br><span class="line">tag1(...) -&gt; tag2(...) -&gt; tag3(...)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>绘制流程图的代码分为两部分：<ol>
<li>定义元素</li>
<li>连接元素</li>
</ol>
</li>
</ol>
<h2 id="定义元素"><a href="#定义元素" class="headerlink" title="定义元素"></a>定义元素</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tag=&gt;type: content:&gt;url</span><br></pre></td></tr></table></figure>

<ol>
<li>代码中的元素含义为：<ul>
<li>tag：标签，即元素的名称；</li>
<li>type：元素的类型；</li>
<li>content：元素块中的内容；</li>
<li>url：链接，给元素上添加超链接。</li>
</ul>
</li>
<li>其中元素的类型有六种：<ul>
<li>start</li>
<li>end</li>
<li>operation</li>
<li>subroutine</li>
<li>condition</li>
<li>inputoutput</li>
</ul>
</li>
</ol>
<h2 id="连接元素"><a href="#连接元素" class="headerlink" title="连接元素"></a>连接元素</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tag1(...) -&gt; tag2(...) -&gt; tag3(...)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用<code>-&gt;</code>符号连接两个元素；</p>
</li>
<li><p>对于<code>condition</code>类型的元素，在标签后面用<code>(yes/no)</code>来表示其不同的<strong>分支</strong>；</p>
</li>
<li><p>对于<strong>被连接的</strong>元素，在标签后面用<code>(right/left)</code>来规定其<strong>位置</strong>；</p>
</li>
<li><p>对于<strong>被连接的</strong><code>condition</code>类型的元素，可以用<code>(yes/no, right/left)</code>来同时确定<strong>分支和位置</strong>。</p>
</li>
</ol>
<h2 id="综合效果"><a href="#综合效果" class="headerlink" title="综合效果"></a>综合效果</h2><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">st=&gt;start: Start|past:&gt;https://hengistyoo.github.io/</span><br><span class="line">e=&gt;end: End:&gt;https://hengistyoo.github.io/</span><br><span class="line">op1=&gt;operation: My Operation|past</span><br><span class="line">op2=&gt;operation: Stuff|current</span><br><span class="line">sub1=&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?|approved:&gt;https://hengistyoo.github.io/</span><br><span class="line">c2=&gt;condition: Good idea|rejected</span><br><span class="line">io=&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<div id="flowchart-0" class="flow-chart"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start|past:>https://hengistyoo.github.io/
e=>end: End:>https://hengistyoo.github.io/
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes
or No?|approved:>https://hengistyoo.github.io/
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>进阶语法</tag>
        <tag>Flowchart</tag>
      </tags>
  </entry>
  <entry>
    <title>「Markdown_02」使用Mermaid绘图</title>
    <url>/2016/09/05/markdown-02/</url>
    <content><![CDATA[<h1 id="安装Mermaid插件"><a href="#安装Mermaid插件" class="headerlink" title="安装Mermaid插件"></a>安装Mermaid插件</h1><ol>
<li>在<strong>Git Bash</strong>中输入<code>npm install --save hexo-filter-mermaid-diagrams</code>。</li>
<li>在Hexo的<code>config.yml</code>文件末尾添加以下内容：</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mermaid chart</span></span><br><span class="line"><span class="attr">mermaid:</span> <span class="comment">## mermaid url https://github.com/knsv/mermaid</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">version:</span> <span class="string">"7.1.2"</span> <span class="comment"># default v7.1.2</span></span><br><span class="line">  <span class="attr">options:</span>  <span class="comment"># find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span><br><span class="line">    <span class="comment">#startOnload: true  // default true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>YOURBLOG/themes/YOURTHEME/layout</code>文件夹中寻找<code>footer.ejs</code>文件，即你的博客下，你正在应用的主题中的<code>layout</code>文件夹中的<code>footer.ejs</code>文件。这个文件的名称可能与<code>footer</code>有出入，但是名称中应当包含<code>footer</code>。在文件末尾添加以下内容：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (theme.mermaid.enable) &#123; %&gt;</span><br><span class="line">  &lt;script src=<span class="string">'https://unpkg.com/mermaid@&lt;%= theme.mermaid.version %&gt;/dist/mermaid.min.js'</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;script&gt;</span></span><br><span class="line"><span class="regexp">    if (window.mermaid) &#123;</span></span><br><span class="line"><span class="regexp">      mermaid.initialize(&#123;theme: 'forest'&#125;);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>其中<code>forest</code>是绘图的主题，不同主题的色彩组合不同，共4种主题可以选择，分别是<code>default</code>、<code>dark</code>、<code>forest</code>、<code>neutral</code>。</p>
<ol start="4">
<li>到这里，我们就可以通过<strong>添加代码块</strong>的方式来绘制图形了，这里要注意，添加的代码块要注明代码类型为<code>mermaid</code>。</li>
</ol>
<h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><h2 id="三种基本线型"><a href="#三种基本线型" class="headerlink" title="三种基本线型"></a>三种基本线型</h2><h3 id="基本线型"><a href="#基本线型" class="headerlink" title="基本线型"></a>基本线型</h3><p>节点之间通过连线来连接，一共有<strong>三种</strong>线型：虚线<code>-.-</code>、实线<code>---</code>、粗实线<code>===</code>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A1 -.- A2</span><br><span class="line">B1 --- B2</span><br><span class="line">C1 === C2</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">graph TB
A1 -.- A2
B1 --- B2
C1 === C2</pre>

<h3 id="带箭头的线型"><a href="#带箭头的线型" class="headerlink" title="带箭头的线型"></a>带箭头的线型</h3><p>在基本线型符号串的右边加上<code>&gt;</code>符号，<strong>去掉左边第1个符号</strong>，使其<strong>仍然保持3个符号</strong>，就获得了带箭头的线型。其中虚线的第一个符号可以不去掉。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A1 .-&gt; A2</span><br><span class="line">B1 --&gt; B2</span><br><span class="line">C1 ==&gt; C2</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph TB
A1 .-> A2
B1 --> B2
C1 ==> C2</pre>

<h3 id="带说明文字的线型"><a href="#带说明文字的线型" class="headerlink" title="带说明文字的线型"></a>带说明文字的线型</h3><p>基本线型和带箭头的线型可以进行组合，中间加上说明文字即可。其中，说明文字左侧的基本线型只取<strong>前两个</strong>符号。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A1 -. 说明文字 -.- A2</span><br><span class="line">B1 -. 说明文字 .-&gt; B2</span><br><span class="line">C1 -- 说明文字 --- C2</span><br><span class="line">D1 -- 说明文字 --&gt; D2</span><br><span class="line">E1 == 说明文字 === E2</span><br><span class="line">F1 == 说明文字 ==&gt; F2</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">graph TB
A1 -. 说明文字 -.- A2
B1 -. 说明文字 .-> B2
C1 -- 说明文字 --- C2
D1 -- 说明文字 --> D2
E1 == 说明文字 === E2
F1 == 说明文字 ==> F2</pre>

<h2 id="四种图形走向"><a href="#四种图形走向" class="headerlink" title="四种图形走向"></a>四种图形走向</h2><p>所有节点之间的连线，都具有方向性，方向共以下四种：</p>
<ul>
<li>TB/TD：从上到下；</li>
<li>BT：从下到上；</li>
<li>LR：从左到右；</li>
<li>RL：从右到左。</li>
</ul>
<p>效果如下：</p>
<pre class="mermaid">graph TB
A1 --> A2</pre>

<pre class="mermaid">graph BT
A1 --> A2</pre>

<pre class="mermaid">graph LR
A1 --> A2</pre>

<pre class="mermaid">graph RL
A1 --> A2</pre>

<h2 id="五种节点形状"><a href="#五种节点形状" class="headerlink" title="五种节点形状"></a>五种节点形状</h2><p>节点默认是矩形的，但是可以通过语法来选定节点的形状，语法如下表。</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>形状</th>
</tr>
</thead>
<tbody><tr>
<td>[ ]</td>
<td>矩形</td>
</tr>
<tr>
<td>( )</td>
<td>圆角矩形</td>
</tr>
<tr>
<td>(( ))</td>
<td>圆形</td>
</tr>
<tr>
<td>{ }</td>
<td>菱形</td>
</tr>
<tr>
<td>&gt; ]</td>
<td>非对称节点</td>
</tr>
</tbody></table>
<p>效果如下：</p>
<pre class="mermaid">graph LR
A[A] --- B(B)
B --- C((C))
C --- D{D}
D --- E>E]</pre>

<h2 id="子图形"><a href="#子图形" class="headerlink" title="子图形"></a>子图形</h2><p>子图形可以被嵌入图形中，以<code>subgraph</code>开始，以<code>end</code>结束。另外，子图形<strong>必须提供标题</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A--&gt;D</span><br><span class="line">A--&gt;F</span><br><span class="line">subgraph 图三</span><br><span class="line">C--&gt;D</span><br><span class="line">C--&gt;G((G))</span><br><span class="line">end</span><br><span class="line">subgraph 图二</span><br><span class="line">A---B</span><br><span class="line">end</span><br><span class="line">subgraph 图一</span><br><span class="line">E-.-F</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">graph TB
A-->D
A-->F
subgraph 图三
C-->D
C-->G((G))
end
subgraph 图二
A---B
end
subgraph 图一
E-.-F
end</pre>

<h1 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h1><h2 id="定义角色"><a href="#定义角色" class="headerlink" title="定义角色"></a>定义角色</h2><p>用<code>participant</code>来定义参与者，用<code>as</code>来增加角色的别名。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">participant A</span><br><span class="line">panticipant B as C</span><br></pre></td></tr></table></figure>

<p>需要注意：</p>
<ul>
<li>定义角色不是必须的，参与者<strong>按照出场先后顺序排列</strong>，如果要把某个角色排在前面，就要定义他。</li>
<li>定义语句不一定要在消息传递之前，放在中间或者后面都可以。</li>
</ul>
<h2 id="消息连线"><a href="#消息连线" class="headerlink" title="消息连线"></a>消息连线</h2><h3 id="基本线型-1"><a href="#基本线型-1" class="headerlink" title="基本线型"></a>基本线型</h3><p>用<code>-&gt;</code>表示实线，用<code>--&gt;</code>表示虚线。</p>
<h3 id="带箭头的线型-1"><a href="#带箭头的线型-1" class="headerlink" title="带箭头的线型"></a>带箭头的线型</h3><p>用<code>-&gt;&gt;</code>表示带箭头的实线，用<code>–-&gt;&gt;</code>表示带箭头的虚线。</p>
<h3 id="带终止符的线型"><a href="#带终止符的线型" class="headerlink" title="带终止符的线型"></a>带终止符的线型</h3><p>用<code>-&gt;&gt;</code>表示带终止符的实线，用<code>–-&gt;&gt;</code>表示带终止符的虚线。</p>
<h3 id="综合效果"><a href="#综合效果" class="headerlink" title="综合效果"></a>综合效果</h3><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt; B:实线</span><br><span class="line">B --&gt; A:虚线</span><br><span class="line">A -&gt;&gt; B:实线箭头</span><br><span class="line">B --&gt;&gt; A:虚线箭头</span><br><span class="line">A -x B:实线终止符</span><br><span class="line">B --x A:虚线终止符</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A -> B:实线
B --> A:虚线
A ->> B:实线箭头
B -->> A:虚线箭头
A -x B:实线终止符
B --x A:虚线终止符</pre>

<h2 id="角色内部任务"><a href="#角色内部任务" class="headerlink" title="角色内部任务"></a>角色内部任务</h2><p>角色本身不仅传递消息，自身还存在任务，需要告诉他<strong>开始处理</strong>及<strong>处理完</strong>自己的任务。开始处理用<code>activate</code>，处理完毕用<code>deactivate</code>。</p>
<p>多数情况下，都是角色在<strong>接收到消息时</strong>才会启动或者结束自身任务，因此有一个快捷的办法，<strong>在消息连线后面加上+/-</strong>，表示接收消息的角色这时候应该<strong>开始/结束</strong>自身任务处理。</p>
<p>另外，如果有多个启动和完成任务的指令，记住他们一定是从最内侧进行配对的。</p>
<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt;&gt;+ B:B启动任务1</span><br><span class="line">B --&gt;&gt; A:消息</span><br><span class="line">activate B</span><br><span class="line">B --&gt;&gt; A:上一句让B启动了任务2。</span><br><span class="line">A -&gt;&gt;- B:B结束了任务，只能匹配任务2</span><br><span class="line">B --x A:这里有个终止符</span><br><span class="line">deactivate B</span><br><span class="line">A -x B:上一句B结束了任务，只能匹配任务1</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A ->>+ B:B启动任务1
B -->> A:消息
activate B
B -->> A:上一句让B启动了任务2。
A ->>- B:B结束了任务，只能匹配任务2
B --x A:这里有个终止符
deactivate B
A -x B:上一句B结束了任务，只能匹配任务1</pre>



<h2 id="贴标签"><a href="#贴标签" class="headerlink" title="贴标签"></a>贴标签</h2><p>给角色贴上便签<code>Note</code>，便签的位置有角色的左边、右边或者上方，但是<strong>没有下方</strong>。</p>
<p>语法是<code>Note left of/right of/over A/B/A,B : Text</code>，要注意的是，只有<code>over</code>后面可以跟随多个对象。</p>
<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">Note over A:A的标签</span><br><span class="line">A -&gt;&gt; B:消息</span><br><span class="line">Note left of A:A的标签</span><br><span class="line">Note right of B:B的标签</span><br><span class="line">B --&gt;&gt; A:消息</span><br><span class="line">Note over A,B:A、B的标签</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
Note over A:A的标签
A ->> B:消息
Note left of A:A的标签
Note right of B:B的标签
B -->> A:消息
Note over A,B:A、B的标签</pre>

<h2 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h2><p>时序在处理的时候，肯定会遇上有条件执行的情况，它的语法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">alt 可选语句说明</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>其中的<code>alt</code>是<code>alternative</code>的缩写，即这有两组时序是二选一的，相当于<code>if-else</code>语句。如果没有<code>else</code>，那么用另外一个关键词<code>opt</code>，它是<code>optional</code>的缩写，语法如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">opt 条件说明</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt;&gt; B: 你好吗？</span><br><span class="line">alt 如果B很好</span><br><span class="line">B --&gt;&gt; A:我很好</span><br><span class="line">else</span><br><span class="line">B --&gt;&gt; A:我不好</span><br><span class="line">end</span><br><span class="line">B -&gt;&gt; A:你有空吗？咱看电影去。</span><br><span class="line">opt A有空</span><br><span class="line">A --&gt;&gt; B: 去吧</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A ->> B: 你好吗？
alt 如果B很好
B -->> A:我很好
else
B -->> A:我不好
end
B ->> A:你有空吗？咱看电影去。
opt A有空
A -->> B: 去吧
end</pre>

<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>把几个语句用<code>loop end</code>语句圈起来，这就是时序循环。语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop 循环语句说明</span><br><span class="line">...</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">participant A</span><br><span class="line">participant B</span><br><span class="line">A -&gt;&gt; B: 有人在吗</span><br><span class="line">B -&gt;&gt; A: 在啊</span><br><span class="line">loop 这俩话痨</span><br><span class="line">A --&gt;&gt; B: 你好</span><br><span class="line">B --&gt;&gt; A: 你好</span><br><span class="line">end</span><br><span class="line">A -&gt;&gt; B: 我不玩了，只会说你好</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">sequenceDiagram
participant A
participant B
A ->> B: 有人在吗
B ->> A: 在啊
loop 这俩话痨
A -->> B: 你好
B -->> A: 你好
end
A ->> B: 我不玩了，只会说你好</pre>



<h1 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="时间及项目标题"><a href="#时间及项目标题" class="headerlink" title="时间及项目标题"></a>时间及项目标题</h3><ul>
<li>时间格式为<code>dateFormat YYYY-MM-DD</code>，定义图中坐标轴的时间格式，可供选择的字符串格式在<a href="http://momentjs.com/docs/#/parsing/string-format/" target="_blank" rel="noopener">这里</a>。</li>
<li>项目标题为<code>title &lt;project title&gt;</code>，项目的标题，中间可以用空格。</li>
</ul>
<h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><ul>
<li>阶段为<code>section &lt;phase name&gt;</code>,描述性字符串中间可以加空格。</li>
</ul>
<h3 id="活动"><a href="#活动" class="headerlink" title="活动"></a>活动</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">活动名</span>&gt;</span></span>:[重要等级],[完成状态],[激活状态],[活动的引用名],[开始时间/依赖],[结束时间/持续时间]</span><br></pre></td></tr></table></figure>

<ul>
<li>活动名：必须。用于描述活动的内容或性质，中间可以包括空格，但不可包含<code>:</code>，因为冒号被用作与后面各项的分隔符。</li>
<li>重要等级：非必须。如果非常重要，则取值<code>crit</code> ，可为空。</li>
<li>完成状态：非必须。如果已完成，则用<code>done</code>表示，可为空。</li>
<li>激活状态：非必须。如果已激活，则为<code>active</code>，可为空。</li>
<li>活动引用名：非必须。给当前活动指定引用名称，以便下方引用，名称中<strong>不能包含空格</strong>。</li>
<li>开始时间：非必须。可以取绝对时间或相对时间。相对时间用<code>after</code>关键字。表示在另外一个活动完成之后开始，如果没有指定，则<strong>默认为上个活动结束的时间</strong>。</li>
<li>结束时间/持续时间：必须。可以是绝对时间，前提是<strong>它的前面应该是绝对时间</strong>。也可以是持续时间。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat  YYYY-MM-DD</span><br><span class="line">title 软件开发甘特图</span><br><span class="line">section 设计</span><br><span class="line">  需求: done, des1, 2014-01-06, 2014-01-08</span><br><span class="line">  原型: active, des2, 2014-01-09, 3d</span><br><span class="line">  UI设计: des3, after des2, 5d</span><br><span class="line">  未来任务: des4, after des3, 5d</span><br><span class="line">section 开发</span><br><span class="line">  学习准备理解需求: crit, done, 2014-01-06, 24h</span><br><span class="line">  设计框架: crit, done, after des2, 2d</span><br><span class="line">  开发: crit, active, 3d</span><br><span class="line">  未来任务: crit, 5d</span><br><span class="line">  耍: 2d</span><br><span class="line">section 测试</span><br><span class="line">  功能测试: active, a1, after des3, 3d</span><br><span class="line">  压力测试: after a1, 20h</span><br><span class="line">  测试报告: 48h</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">gantt
dateFormat  YYYY-MM-DD
title 软件开发甘特图
section 设计
  需求: done, des1, 2014-01-06, 2014-01-08
  原型: active, des2, 2014-01-09, 3d
  UI设计: des3, after des2, 5d
  未来任务: des4, after des3, 5d
section 开发
  学习准备理解需求: crit, done, 2014-01-06, 24h
  设计框架: crit, done, after des2, 2d
  开发: crit, active, 3d
  未来任务: crit, 5d
  耍: 2d
section 测试
  功能测试: active, a1, after des3, 3d
  压力测试: after a1, 20h
  测试报告: 48h</pre>

<h1 id="类结构图"><a href="#类结构图" class="headerlink" title="类结构图"></a>类结构图</h1><p>代码如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">Class01 <span class="xml"><span class="tag">&lt;<span class="name">|--</span> <span class="attr">AveryLongClass</span> <span class="attr">:</span> <span class="attr">Cool</span></span></span></span><br><span class="line"><span class="xml">Class03 *-- Class04</span></span><br><span class="line"><span class="xml">Class05 o-- Class06</span></span><br><span class="line"><span class="xml">Class07 .. Class08</span></span><br><span class="line"><span class="xml">Class09 --&gt;</span> C2 : Where am i?</span><br><span class="line">Class09 --* C3</span><br><span class="line">Class09 --|&gt; Class07</span><br><span class="line">Class07 : equals()</span><br><span class="line">Class07 : Object[] elementData</span><br><span class="line">Class01 : size()</span><br><span class="line">Class01 : int chimp</span><br><span class="line">Class01 : int gorilla</span><br><span class="line">Class08 <span class="xml"><span class="tag">&lt;<span class="name">--</span>&gt;</span></span> C2: Cool label</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<pre class="mermaid">classDiagram
Class01 <|-- AveryLongClass : Cool
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 --> C2 : Where am i?
Class09 --* C3
Class09 --|> Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
Class08 <--> C2: Cool label</pre>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>进阶语法</tag>
        <tag>Mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>「Markdown_01」基本语法</title>
    <url>/2016/09/01/markdown-01/</url>
    <content><![CDATA[<h1 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h1><h2 id="通用标题设置"><a href="#通用标题设置" class="headerlink" title="通用标题设置"></a>通用标题设置</h2><p>使用<code>#</code>符号来设置<strong>不同级别</strong>的标题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote>
<h2 id="前两级标题设置"><a href="#前两级标题设置" class="headerlink" title="前两级标题设置"></a>前两级标题设置</h2><p><strong>一级标题</strong>使用<code>=</code>来设置，<strong>二级标题</strong>使用<code>-</code>来设置。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">===</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p>&nbsp;</p>
<h1 id="自然段换行"><a href="#自然段换行" class="headerlink" title="自然段换行"></a>自然段换行</h1><h2 id="新的自然段"><a href="#新的自然段" class="headerlink" title="新的自然段"></a>新的自然段</h2><p>只需要在两个自然段之间<strong>空一行</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第一段</span><br><span class="line"></span><br><span class="line">第二段</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>第一段</p>
<p>第二段</p>
</blockquote>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>在<strong>行末</strong>加<strong>两个空格</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">第一行  </span><br><span class="line">第二行</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>第一行<br>第二行</p>
</blockquote>
<p>&nbsp;</p>
<h1 id="引用表现"><a href="#引用表现" class="headerlink" title="引用表现"></a>引用表现</h1><p>在<strong>行首</strong>加<code>&gt;</code>即可添加引用格式。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用这段话</span></span><br><span class="line">&gt;&gt;&gt; 多重引用这段话</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>引用这段话</p>
<blockquote>
<blockquote>
<p>多重引用这段话</p>
</blockquote>
</blockquote>
</blockquote>
<p>&nbsp;</p>
<h1 id="增加分割线"><a href="#增加分割线" class="headerlink" title="增加分割线"></a>增加分割线</h1><p>使用<code>---</code>、<code>***</code>、<code>___</code>、<code>- - -</code>都可以为文章增加分割线，其中<code>---</code><strong>与二级标题的区别</strong>在于，二级标题的<code>---</code>上一行是文字，而分割线的上一行是空行。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">___</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>- -</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<hr>
<hr>
<hr>
<hr>
</blockquote>
<p>&nbsp;</p>
<h1 id="强调表现"><a href="#强调表现" class="headerlink" title="强调表现"></a>强调表现</h1><p>将<strong>单个</strong><code>*</code> 或<code>_</code>加在文字两侧，就是<strong>斜体</strong>；将<strong>连续两个</strong><code>*</code> 或<code>_</code>加在文字两侧，就是<strong>粗体</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体*</span> <span class="emphasis">_斜体_</span></span><br><span class="line"><span class="strong">**粗体**</span> <span class="strong">__粗体__</span></span><br><span class="line"><span class="strong">***粗斜体**</span>* <span class="strong">___粗斜体__</span>_</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><em>斜体</em> <em>斜体</em><br><strong>粗体</strong> <strong>粗体</strong><br><strong><em>粗斜体</em></strong> <strong><em>粗斜体</em></strong></p>
</blockquote>
<p>&nbsp;</p>
<h1 id="列表表现"><a href="#列表表现" class="headerlink" title="列表表现"></a>列表表现</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>将<code>-</code>、<code>*</code>、<code>+</code>符号置于行首，用<strong>两个空格分等级</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>无序列表</span><br><span class="line"><span class="bullet">  - </span>无序列表</span><br><span class="line"><span class="bullet">    - </span>无序列表</span><br><span class="line"><span class="bullet">* </span>无序列表</span><br><span class="line"><span class="bullet">+ </span>无序列表</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<ul>
<li>无序列表<ul>
<li>无序列表<ul>
<li>无序列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
</blockquote>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>用<strong>后面带<code>.</code>的数字</strong>置于行首，用两个空格分级。有序列表会<strong>从第一个条目前面的数字开始排序</strong>，为了便于插入新的条目，建议第一个条目用<code>1</code>，其他条目用<code>0</code>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>有序列表</span><br><span class="line"><span class="bullet">0. </span>有序列表</span><br><span class="line"><span class="bullet">  1. </span>有序列表</span><br><span class="line"><span class="bullet">  0. </span>有序列表</span><br><span class="line"><span class="bullet">  0. </span>有序列表</span><br><span class="line"><span class="bullet">0. </span>有序列表</span><br><span class="line"><span class="bullet">0. </span>有序列表</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<ol>
<li>有序列表</li>
<li>有序列表<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
</blockquote>
<p>&nbsp;</p>
<h1 id="超文本链接"><a href="#超文本链接" class="headerlink" title="超文本链接"></a>超文本链接</h1><p>超文本链接有以下四种写法，<strong>前两种写法</strong>会将链接直接显示出来，<strong>第三种写法</strong>可以显示指定的文字，<strong>第四种写法</strong>可以增加一个鼠标悬停的标题。 </p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">https://hengistyoo.github.io/</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">https:</span>//<span class="attr">hengistyoo.github.io</span>/&gt;</span></span></span><br><span class="line">[<span class="string">豆豆的小笔记</span>](<span class="link">https://hengistyoo.github.io/</span>)</span><br><span class="line">[<span class="string">豆豆的小笔记</span>](<span class="link">https://hengistyoo.github.io/ "你好呀，我是豆豆！"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><a href="https://hengistyoo.github.io/">https://hengistyoo.github.io/</a><br><a href="https://hengistyoo.github.io/">https://hengistyoo.github.io/</a><br><a href="https://hengistyoo.github.io/">豆豆的小笔记</a><br><a href="https://hengistyoo.github.io/" title="你好呀，我是豆豆！">豆豆的小笔记</a></p>
</blockquote>
<p>&nbsp;</p>
<h1 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h1><h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>用反单引号<code>`</code>符号来引用，如果要引用反单引号，则可以使用<strong>一对两个反单引号</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">您可以使用<span class="code">`add(x,y)`</span>函数计算两个数的和。</span><br><span class="line">反单引号是<span class="code">```</span>`` 。</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>您可以使用<code>add(x,y)</code>函数计算两个数的和。<br>反单引号是<code>`</code>。</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>用<strong>连续三个</strong><code>`</code>或<code>~</code>来显示代码块，可以在第一行末尾注明代码的语言名。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">​<span class="code">```</span>c++</span><br><span class="line">int main()&#123;</span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">效果如下：</span><br><span class="line"></span><br><span class="line">&gt; &#96;&#96;&#96;c++</span><br><span class="line">&gt; int main()&#123;</span><br><span class="line">&gt;     return 0;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>


<p>&nbsp;</p>
<h1 id="图片显示"><a href="#图片显示" class="headerlink" title="图片显示"></a>图片显示</h1><h2 id="无链接图片"><a href="#无链接图片" class="headerlink" title="无链接图片"></a>无链接图片</h2><p>使用<code>![]()</code>来显示图片，方括号中填写的是<strong>alt文字</strong>，即在找不到图片或图片加载出来之前显示的文字；圆括号中填写的是<strong>图片url</strong>和<strong>图片title</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">Doge</span>](<span class="link">dog.jpeg "狗子"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><img src="dog.jpeg" alt="Doge" title="狗子"></p>
</blockquote>
<h2 id="带链接图片"><a href="#带链接图片" class="headerlink" title="带链接图片"></a>带链接图片</h2><p>将<strong>超链接的语法套在图片的语法上</strong>，即<code>[![]()]()</code>。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">![Doge</span>](<span class="link">dog.jpeg "狗子"</span>)](<span class="link">https://hengistyoo.github.io/ "你好呀，我是豆豆！"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p><a href="https://hengistyoo.github.io/" title="你好呀，我是豆豆！"><img src="dog.jpeg" alt="Doge" title="狗子"></a></p>
</blockquote>
<p>&nbsp;</p>
<h1 id="表格显示"><a href="#表格显示" class="headerlink" title="表格显示"></a>表格显示</h1><h2 id="表格制作"><a href="#表格制作" class="headerlink" title="表格制作"></a>表格制作</h2><p>使用<code>-</code>和<code>|</code>来制作表格。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| TH1  | TH2  | TH3  |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| TD1  | TD2  | TD3  |</span><br><span class="line">| TD4  | TD5  | TD6  |</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>TH1</th>
<th>TH2</th>
<th>TH3</th>
</tr>
</thead>
<tbody><tr>
<td>TD1</td>
<td>TD2</td>
<td>TD3</td>
</tr>
<tr>
<td>TD4</td>
<td>TD5</td>
<td>TD6</td>
</tr>
</tbody></table>
<h2 id="表格对齐"><a href="#表格对齐" class="headerlink" title="表格对齐"></a>表格对齐</h2><p>使用<code>:</code>来实现表格对齐。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| TH1  | TH2  | TH3  |</span><br><span class="line">| :--- | :---: | ---: |</span><br><span class="line">| TD1  | TD2  | TD3  |</span><br><span class="line">| TD4  | TD5  | TD6  |</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th align="left">TH1</th>
<th align="center">TH2</th>
<th align="right">TH3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TD1</td>
<td align="center">TD2</td>
<td align="right">TD3</td>
</tr>
<tr>
<td align="left">TD4</td>
<td align="center">TD5</td>
<td align="right">TD6</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>基本语法</tag>
      </tags>
  </entry>
  <entry>
    <title>「Hexo_01」使用Hexo搭建Blog</title>
    <url>/2016/08/26/hexo-01/</url>
    <content><![CDATA[<h1 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>Node.js是一个基于Chrome V8引擎的<strong>JavaScript运行环境</strong>。需要进入<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js官网</a>下载安装。</p>
<p>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</p>
<p>其它的安装方法：</p>
<ul>
<li>Windows：通过 nvs（推荐）或者nvm 安装。</li>
<li>Mac：使用 Homebrew 或 MacPorts 安装。</li>
<li>Linux（DEB/RPM-based）：从 NodeSource 安装。</li>
<li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导</li>
</ul>
<p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p>
<blockquote>
<p>Windows 用户</p>
<p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p>
</blockquote>
<blockquote>
<p>For Mac / Linux 用户</p>
<p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally" target="_blank" rel="noopener">由 npmjs 发布的指导</a> 修复该问题。强烈建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p>
</blockquote>
<blockquote>
<p><strong>测试安装成功</strong>需要在<code>cmd</code>中输入<code>node -v</code>，输出Node.js的版本号即为安装成功。</p>
</blockquote>
<h1 id="注册代码托管平台"><a href="#注册代码托管平台" class="headerlink" title="注册代码托管平台"></a>注册代码托管平台</h1><blockquote>
<p>为了后期部署方便，这里建议使用<strong>同一个</strong>邮箱来注册不同平台。</p>
</blockquote>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ol>
<li>登录<a href="https://github.com/" target="_blank" rel="noopener">GitHub网站</a>注册GitHub账号。</li>
<li>点击<strong>New repository</strong>按钮新建仓库，仓库命名要和GitHub的用户名<strong>保持一致</strong>，例如我的GitHub的用户名为<strong>HengistYoo</strong>，我这里的仓库名就叫做<strong>HengistYoo.github.io</strong>。仓库的其他参数保持默认即可。</li>
</ol>
<h2 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a>Gitee</h2><ol>
<li>登录<a href="https://gitee.com/" target="_blank" rel="noopener">码云网站</a>注册账号。</li>
<li>点击<strong>新建仓库</strong>按钮新建仓库，仓库命名要和Gitee的用户名<strong>保持一致</strong>，例如我的Gitee的用户名为<strong>HengistYoo</strong>，我这里的仓库名就叫做<strong>HengistYoo</strong>，注意这里的命名<strong>和GitHub不同</strong>。仓库的其他参数保持默认即可。</li>
</ol>
<h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><ul>
<li>Windows：下载并安装 git.</li>
<li>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</li>
<li>Linux (Ubuntu, Debian)：sudo apt-get install git-core</li>
<li>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</li>
</ul>
<blockquote>
<p><strong>Mac 用户</strong><br>如果在编译时可能会遇到问题，请先到App Store安装Xcode，Xcode完成后，启动并进入Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install安装命令行工具。</p>
</blockquote>
<blockquote>
<p><strong>Windows 用户</strong><br>对于中国大陆地区用户，可以前往<a href="https://npm.taobao.org/mirrors/git-for-windows/" target="_blank" rel="noopener">淘宝 Git for Windows 镜像</a>下载 git 安装包。</p>
</blockquote>
<blockquote>
<p><strong>测试安装成功</strong>需要在<code>cmd</code>中输入<code>git --version</code>，输出Git的版本号即为安装成功。</p>
</blockquote>
<h1 id="托管平台SSH配置"><a href="#托管平台SSH配置" class="headerlink" title="托管平台SSH配置"></a>托管平台SSH配置</h1><blockquote>
<p>上传代码可以通过远程SSH链接，其中使用SSH Keys来进行远程登录安全验证。</p>
</blockquote>
<p>在Git bash中输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"name@xx.com"</span></span><br></pre></td></tr></table></figure>

<p>其中，最后一个参数输入注册GitHub和Gitee的邮箱，然后一路回车，就可以创建SSH Key。</p>
<p>到<code>C:\Users\YOURNAME\.ssh</code>路径下，将<code>id_rsa.pub</code>文件的内容添加到GitHub和Gitee的SSH Key当中。</p>
<h1 id="更换npm源"><a href="#更换npm源" class="headerlink" title="更换npm源"></a>更换npm源</h1><p>后面要用到npm命令下载一些文件，直接访问速度比较慢，因此这里将npm源更换为国内的<strong>淘宝源</strong>。</p>
<h2 id="单次使用"><a href="#单次使用" class="headerlink" title="单次使用"></a>单次使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="永久使用"><a href="#永久使用" class="headerlink" title="永久使用"></a>永久使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>检查是否配置成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<p>如果要还原：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>

<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>在想要安装Hexo的路径下执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init YOURBLOGNAME</span><br><span class="line"><span class="built_in">cd</span> YOURBLOGNAME</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>搭建博客</tag>
      </tags>
  </entry>
</search>
